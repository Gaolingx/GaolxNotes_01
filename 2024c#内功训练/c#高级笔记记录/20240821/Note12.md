# C#高级编程之——特性（一）介绍

在上一个章节中我们学习了C#的拓展方法的概念和使用，我们也尝试着自己写了一个拓展方法，今天我们开始系统性的学习c#中的特性。

## 1.1 特性的介绍

相信通过之前的简单介绍，大家对特性也有了简单的了解，这里再简单的回顾下：

简单理解：对方法的拓展，而无需修改原方法。

特性具有以下属性：

- 特性向程序添加元数据。 元数据是程序中定义的类型的相关信息。 所有 .NET 程序集都包含一组指定的元数据，用于描述程序集中定义的类型和类型成员。 可以添加自定义特性来指定所需的其他任何信息。 有关详细信息，请参阅创建自定义特性 (C#)。
- 可以将一个或多个特性应用于整个程序集、模块或较小的程序元素（如类和属性）。
- 特性可以像方法和属性一样接受自变量。
- 程序可使用反射来检查自己的元数据或其他程序中的元数据。 有关详细信息，请参阅使用反射访问特性 (C#)。

## 1.2 预定义特性（系统内置特性）

.NET框架提供了一些预定义特性，这些特性在编译时和运行时都有特定的用途。常见的预定义特性包括：

1. **ObsoleteAttribute**：用于标记某个程序元素（如类、方法、属性等）为过时。尝试使用被标记为过时的元素时，编译器会发出警告或错误。

   ```csharp
   [Obsolete("此方法是过时的，请使用新方法")]
   public void OldMethod()
   {
       // 方法实现
   }
   ```

2. **DllImportAttribute**：用于调用非托管代码（如C或C++编写的DLL中的函数）。这对于与本地库交互非常有用。

   ```csharp
   [DllImport("kernel32.dll")]
   public static extern void SetLastError(int dwErrCode);
   ```

3. **ConditionalAttribute**：用于定义条件编译的方法。这意味着可以根据特定的编译符号来包含或排除方法的调用。

   ```csharp
   [Conditional("DEBUG")]
   public static void DebugMessage(string message)
   {
       Console.WriteLine(message);
   }
   ```

4. **SerializableAttribute**：指示一个类可以被序列化。这对于对象状态的保存和恢复非常有用，比如在网络通信或数据持久化时。

   ```csharp
   [Serializable]
   public class MyClass
   {
       // 类定义
   }
   ```

5. **AttributeUsage**：用于定义特性类的使用方式，包括它可以被应用到哪些类型的程序元素上，是否可以多次使用，以及是否可以被派生类继承。

## 2. 自定义特性

除了预定义特性外，C#还允许开发者创建自定义特性。自定义特性的创建需要遵循以下步骤：

1. 定义一个从`System.Attribute`派生的类。
2. 在该类中定义所需的属性或字段，这些属性或字段将作为特性的参数。
3. 使用`AttributeUsage`特性（可选）来定义自定义特性的使用方式。

## 3. 特性的查询

在运行时，可以通过反射技术来查询程序元素上的特性。这包括获取特性的实例、读取特性的属性或字段值等，例如使用GetCustomAttributes方法用于获取指定类型的特性。

## 4. 特性的优势

* **增强代码的可读性和可维护性**：通过为程序元素添加描述性信息，使得其他开发者更容易理解代码的目的和用法。
* **实现灵活的编译时和运行时行为**：通过预定义特性和自定义特性，可以在编译时和运行时控制程序的行为，实现灵活的编程模式。
* **支持高级编程技术**：如依赖注入、AOP（面向切面编程）等，这些技术都依赖于特性来提供必要的元数据和声明性信息。

通过使用特性，可以有效地将元数据或声明性信息与代码（程序集、类型、方法、属性等）相关联，并通过反射技术在运行时查询这些信息。将特性与程序实体相关联后，可以在运行时使用反射这项技术查询特性，常运用于AOP技术。特性的使用可以增强代码的可读性、可维护性和灵活性，支持高级编程技术的实现。
