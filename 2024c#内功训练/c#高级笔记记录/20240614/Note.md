# C#高级编程之——反射

## 什么是反射，反射有什么用，它能干什么？

- 作为c#高级特性之一，在很多领域都有反射的身影，比如textJson反序列化、ORM框架、ABP框架等，可以说，如果你接触c#高级开发或者想成为一名架构师，反射是一个必须掌握的特性。
- 比如说，我们可以用反射去研究一些黑盒，尝试访问些引擎/SDK等dll没有公开暴露的属性，做黑箱测试。

<br>

- 官方概念：反射指**程序可以访问、检测和修改它本身（例如元数据）状态或行为的一种能力**。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型、命名空间。然后，可以调用类型的方法或访问其字段和属性。（除了私有构造方法，包括private成员/方法，我们都是可以通过反射查看/调用的。）
- 一句话总结：反射可以看清类/对象的本质，我们可以获取到他底下 的方法/属性，类似照妖镜。

<br>

- 程序集（Assembly）：先来看看官方概念：程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。 emmm...这说了跟没说一样，简单来说，程序集就像一个文件夹或包裹，**程序集包含了应用程序所需的所有类型（如类、接口等）和资源**，程序集可以包含一个或多个模块。
- 程序集长啥样呢，通常在文件夹看到的可执行文件（.exe文件）和 类库文件（.dll文件）便是，vs里面一个解决方案可以包含多个项目，而每个项目就是一个程序集，如图所示：
  
- 程序集包含一个清单，这是一个元数据部分，它描述了程序集的名称、版本、发布者、引用的类型等信息。这个清单使得.NET运行时（CLR）能够确定如何加载和使用程序集中的代码。即每个程序集都有一个版本号和一个清单，用于描述程序集的内容和依赖关系，如图所示：
- 当然了，我们也可以使用反射，以编程方式获取程序集的相关信息，这也是我们这章要重点研究的。

<br>

- 元数据（Metadata）：我们已经知道反射允许你在运行时获取关于类型的信息，如类的名称、成员（字段、属性、方法、事件等）、基类和实现的接口等。而这些信息就存储在元数据中，但反射提供了API来查询和使用这些元数据。
- 注意：元数据并不包括具体的数据，比如我创建了一个 int a = 3,int b = 5，这里面int是一个type，它是元数据的一部分，而后面的3,5则是具体的数据，当我使用了int a = function,那么这个行为就构成了元数据，因为function结果是不确定的，这个function也可以存在interface里（interface可以传递元数据，不能表示元数据）。再比如，我创建了一个public class xxx，那这个class也是元数据，因为它规定了这个函数的behavior，但是我定义一个interface xxx,那它就不是元数据了，因为interface本身不是behavior，但是我们可以补充behavior，但不论是class也好interface也好，这两个玩意都能传递元数据，只是说class除了和interface一样可以传递behavior，还能传递字段，field。
- 如图，在这个例子中，可以自己跟着敲一遍，跟着注释，对元数据有个简单的了解，可以更好的帮助后面我们理解

<br>

- 有点扯远了，现在无法理解他们的概念也无妨，你只要知道元数据是对行为的补充，至于行为如何执行，这个就是解释器要做的事，由他来invoke你写的behavior，该过程用户无需关心。举个例子，你在unity中，继承自monobehavior的类都是元数据，至于Start，Awake这种函数，EventSystem相关的事件函数，也是通过补充元数据的方式交给unity的解释器执行，当然了，这样的解释器也允许开发者自己去实现，从而去判断/解析用户的behavior执行相应的方法。这与传统的业务层面中面向对象(OOP)有比较大的差异。
- 一句话的总结：在基于元数据的开发中，行为是元数据的一部分，它本身并不关心行为是如何实现的，具体的实现是通过补充元数据的方式在解释器中执行的。