# C#高级编程之——反射（一）

## 一、反射入门——基本概念介绍

### 什么是反射，反射有什么用，它能干什么？

- Reflection，中文翻译为反射，这是.Net中获取运行时类型信息的方式。作为c#高级特性之一，在很多领域都有反射的身影，比如Ioc容器、Json/XML反序列化、ORM框架(EFCore)、ABP框架等，可以说，如果你接触c#高级开发或者想成为一名架构师，反射是一个必须掌握的特性。
- 比如说，我们可以用反射去研究一些黑盒，尝试访问些引擎/SDK等dll没有公开暴露的属性，做黑箱测试。

<br>

- 官方概念：反射指**程序可以访问、检测和修改它本身（例如元数据）状态或行为的一种能力**。.Net的应用程序结构分为应用程序域(AppDomain)—程序集(Assembly)—模块(Module)—类型(class)—成员(member)几个层次，公共语言运行库(CLR)加载器管理应用程序域，这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员（这些信息都是可以运通过反射获取的）。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型、命名空间。然后，可以调用类型的方法或访问其字段和属性。（除了私有构造方法，包括private成员/方法，我们都是可以通过反射查看/调用的。）
- 一句话总结：反射可以看清类/对象的所有信息（知道你是谁、继承了谁，引用了谁等等），我们可以通过反射，在运行时获得.NET中每一个类型（包括类、结构、委托、接口和枚举等）的成员，包括方法、属性、事件，以及构造函数等，还可以获得每个成员的名称、限定符和参数等，类似照妖镜。

- 反射的三大功能：

1. 查看和遍历类型(及其成员)的基本信息和程序集元数据(metadata)
2. 迟绑定(Late-Binding)方法和属性。
3. 动态创建类型实例(并可以动态调用所创建的实例的方法、字段、属性)。

<br>

### 程序集、模块和类型概念及关系

一、程序集（Assembly）：先来看看官方概念：程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。 emmm...这说了跟没说一样，简单来说，程序集就像一个文件夹或包裹，**程序集包含了应用程序所需的所有类型（如类、接口等）和资源**，程序集可以包含一个或多个模块。

程序集长啥样呢，通常在文件夹看到的可执行文件（.exe文件）和 类库文件（.dll文件）便是，vs里面一个解决方案可以包含多个项目，而每个项目就是一个程序集，如图所示：
  
程序集包含一个清单，这是一个元数据部分，它描述了程序集的名称、版本、发布者、引用的类型等信息。这个清单使得.NET运行时（CLR）能够确定如何加载和使用程序集中的代码。即每个程序集都有一个版本号和一个清单，用于描述程序集的内容和依赖关系，如图所示：

其中核心元素包括：

- 类型：程序集中定义的所有类型。
- 清单文件：包含程序集元数据的信息，例如名称、版本、依赖项等。
- 资源：程序集中使用的资源，例如图像、声音、文本等。程序集通常对应一个物理文件，例如 EXE 或 DLL 文件。程序集可以显式或隐式地加载到应用程序中。显式加载程序集使用 Assembly.Load() 方法，隐式加载程序集通常发生在应用程序引用其他程序集时。

当然了，我们也可以使用反射，以编程方式获取程序集的相关信息，这也是我们这章要重点研究的。

<br>

二、模块（Module）：
模块是程序集中的逻辑单元，它通常对应一个 .cs 源文件。作为构成.NET应用程序的基本单元之一，模块包含以下元素：

- 类型：模块中定义的所有类型。
- 中间代码 (IL)：由编译器生成的机器码表示的类型实现。
- 元数据：有关类型的信息，例如名称、属性、方法等。
模块通常是程序集的一部分，但也可以单独编译和加载。例如，一些库可能会提供多个模块，每个模块包含不同的功能。

<br>

三、元数据（Metadata）：作为模块的一部分，我们已经知道反射允许你在运行时获取关于类型的信息，如类的名称、成员（字段、属性、方法、事件等）、基类和实现的接口等。而这些信息就存储在元数据中，但反射提供了API来查询和使用这些元数据，元数据包括methodInfo，TypeInfo，interface，baseClass，attribute等。

<br>

- 注：尽管元数据的概念对大多数csharp开发者是陌生的，但是在实际开发中却随处可见，举个例子，你在unity中，继承自monobehavior的类都是元数据，例如Start，Awake这种函数，EventSystem相关的事件函数，也是通过补充元数据的方式交给unity的解释器执行，当然了，这样的解释器也允许开发者自己去实现，从而去判断/解析用户的behavior执行相应的方法。这与传统的业务层面中面向对象(OOP)有比较大的差异。现在无法理解他们的概念也无妨，你只要知道元数据是对行为的补充与描述，至于行为如何执行，这个就是解释器要做的事，由他来invoke你写的behavior，该过程用户无需关心。
- 一句话的总结：在基于元数据的开发中，行为是元数据的一部分，它本身并不关心行为是如何实现的，具体的实现是通过补充元数据的方式在解释器中执行的。

<br>

四：类型（Type）：类型是程序集或模块中定义的代码结构，它代表一种实体或行为。类型包含以下元素：

- 字段：存储数据的成员变量。
- 属性：提供对字段的封装访问。
- 方法：实现功能的代码块。
- 事件：用于通知应用程序中其他部分的事件。
- 构造函数：用于创建类型实例的代码块。

一句话总结：类型是面向对象编程的核心概念。它们用于表示应用程序中的对象和行为。

### 程序集、模块和类型的关系

- 程序集 可以包含多个模块。
- 模块 可以包含多个类型。
- 类型 只能属于一个模块。

他们的关系可以如下图所示：



总结：

- Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并且创建该类型的实例。Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性、字段等等，通过Type类可以得到这些要素的信息，并且调用。除此之外，还有列如FieldInfo、EventInfo等等，这些类都包含在System.Reflection命名空间下。

- 程序集、模块和类型是 C# 中构成 .NET 应用程序的基本单元。它们之间具有层次关系，程序集包含模块，模块包含类型。每个单元都包含特定的元素和功能，共同构成了完整的应用程序。

```csharp
/*- 注意：元数据并不包括具体的数据，比如我创建了一个 int a = 3,int b = 5，这里面int是一个type，它是元数据的一部分，而后面的3,5则是具体的数据，当我使用了int a = function,那么这个行为就构成了元数据，因为function结果是不确定的，这个function也可以存在interface里（interface可以传递元数据，不能表示元数据）。再比如，我创建了一个public class xxx，那这个class也是元数据，因为它规定了这个函数的behavior，但是我定义一个interface xxx,那它就不是元数据了，因为interface本身不是behavior，但是我们可以补充behavior，但不论是class也好interface也好，这两个玩意都能传递元数据，只是说class除了和interface一样可以传递behavior，还能传递字段，field。
- 如图，在这个例子中，可以自己跟着敲一遍，跟着注释，对元数据有个简单的了解，可以更好的帮助后面我们理解*/
```