# C#多线程与异步编程（四）

### 3.4 异步方法（async Task）

在异步方法中，将方法标记 `async` 后，可以在方法中使用 `await` 关键字，`await` 关键字会等待异步任务的结束，并获得结果。

#### 3.1 异步方法的实现

1. 执行异步任务，输出线程id

```csharp
[Test]
public async Task TestGetThreadId()
{
    Helper.PrintThreadId("Before");
    await FooAsync();
    Helper.PrintThreadId("After");
}

async Task FooAsync()
{
    Helper.PrintThreadId("Before");
    await Task.Delay(1000);
    Helper.PrintThreadId("After");
}

class Helper
{
    private static int index = 1;
    public static void PrintThreadId(string? message = null, [CallerMemberName] string? name = null)
    {
        var title = $"index: {index}, CallerMemberName: {name}";
        if (!string.IsNullOrEmpty(message))
            title += $" @ {message}";
        Console.WriteLine($"Thread id: {Environment.CurrentManagedThreadId}, {title}");
        Interlocked.Increment(ref index);
    }
}
```

可以看到输出的结果为：
Thread id: 16, index: 1, CallerMemberName: TestGetThreadId @ Before
Thread id: 16, index: 2, CallerMemberName: FooAsync @ Before
Thread id: 9, index: 3, CallerMemberName: FooAsync @ After
Thread id: 9, index: 4, CallerMemberName: TestGetThreadId @ After

**代码执行流程：**

1. **`TestGetThreadId`方法**  
   - **`Before`输出**：在调用线程（假设是主线程，线程ID为A）执行。
   - **调用`await FooAsync()`**：进入`FooAsync`，执行其`Before`输出（线程A）。
   - **遇到`Task.Delay(1000)`**：返回未完成的`Task`，`FooAsync`挂起，控制权返回到`TestGetThreadId`。
   - **`TestGetThreadId`的`await`挂起**：返回一个`Task`给调用者（如测试框架），主线程被释放。

2. **`FooAsync`的恢复**  
   - **`Task.Delay(1000)`完成**：由线程池调度一个线程（假设线程B）执行`FooAsync`的后续代码。
   - **`After`输出**：在线程B执行，`FooAsync`的`Task`标记为完成。

3. **`TestGetThreadId`的恢复**  
   - **`FooAsync`完成后**：线程池调度一个线程（可能是B或其他线程C）执行`TestGetThreadId`的`After`输出。

在此过程中：
1. **await释放线程**：当异步操作未完成时，await会立即返回Task，释放当前线程（主线程可处理其他任务）。
2. **线程池调度延续**：异步操作完成后，延续任务由线程池执行，不依赖原线程。

注：可以看到。当执行完 **FooAsync()**后，没有回到之前的线程（线程id：16->9）

在UI/ASP.NET等有同步上下文的场景中，可以通过`ConfigureAwait(true)`，延续任务执行完后回到原线程（如UI线程），但是在控制台应用程序中，则不会回到主线程。

---

### 3.2 async/await 关键字的本质是异步状态机

C# 中的 `async Task` 本质上是一个语法糖，其内部实现依赖于一个**状态机（State Machine）**。这种设计是为了让开发者能够以同步代码的编写方式，实现异步操作的逻辑，而无需手动处理复杂的线程、回调或状态管理。以下是详细的解释：

---

### 1. **语法糖的本质**
`async` 和 `await` 关键字是 C# 5.0 引入的语法糖，目的是简化异步编程模型（Task-based Asynchronous Pattern, TAP）。它们让开发者可以用类似同步代码的结构编写异步逻辑，避免了传统异步编程中回调嵌套（Callback Hell）的问题。

例如：
```csharp
public async Task DoWorkAsync()
{
    var result1 = await LongOperation1Async();
    var result2 = await LongOperation2Async(result1);
    Console.WriteLine(result2);
}
```

这段代码在语法上看起来是“同步”的，但实际上会被编译器转换为一个**状态机**，管理异步操作的执行流程。

---

### 2. **状态机的工作原理**
当编译器遇到 `async` 方法时，会自动生成一个**状态机类**（通常命名为类似 `<DoWorkAsync>d__1`），该类实现了 `IAsyncStateMachine` 接口。状态机的主要职责是：
1. **跟踪代码执行位置**：记录 `await` 之后的代码需要从何处恢复。
2. **保存局部变量和参数**：确保异步操作恢复时上下文一致。
3. **管理 `Task` 的生命周期**：处理完成、取消或异常情况。

#### 关键步骤：
- **初始状态**：状态机初始化，开始执行代码。
- **遇到 `await`**：暂停当前方法，向调用方返回一个 `Task`。
- **异步操作完成**：状态机通过 `MoveNext()` 方法恢复执行，跳转到正确的代码位置（通过状态标识符）。

---

### 3. **编译器的代码转换**
编译器会将原始的 `async` 方法转换为一个状态机结构。例如，上述 `DoWorkAsync` 会被转换为类似以下的伪代码：

```csharp
// 编译器生成的状态机类
private sealed class <DoWorkAsync>d__1 : IAsyncStateMachine
{
    public int state;          // 当前状态（如 -1: 初始状态, 0: 第一个 await 后, 1: 第二个 await 后）
    public AsyncTaskMethodBuilder builder; // 用于构建和返回 Task
    private TaskAwaiter awaiter;           // 等待异步操作完成的对象

    // 局部变量会被“提升”为字段，以保持状态
    private string result1;
    private string result2;

    void IAsyncStateMachine.MoveNext()
    {
        switch (state)
        {
            case -1:
                // 初始代码：执行第一个 await
                awaiter = LongOperation1Async().GetAwaiter();
                if (awaiter.IsCompleted)
                {
                    // 如果操作已经完成，直接继续执行
                    goto case 0;
                }
                else
                {
                    state = 0;
                    builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
                    return; // 暂停并返回 Task
                }
            case 0:
                // 恢复执行第一个 await 之后的代码
                result1 = awaiter.GetResult();
                // 执行第二个 await
                awaiter = LongOperation2Async(result1).GetAwaiter();
                if (awaiter.IsCompleted)
                {
                    goto case 1;
                }
                else
                {
                    state = 1;
                    builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
                    return; // 再次暂停
                }
            case 1:
                // 恢复执行第二个 await 之后的代码
                result2 = awaiter.GetResult();
                Console.WriteLine(result2);
                builder.SetResult(); // 标记 Task 完成
                break;
        }
    }

    // 其他接口方法（如 SetStateMachine）省略...
}
```

---

### 4. **状态机的核心作用**
- **代码分割**：每个 `await` 会将方法分割为多个“阶段”，状态机通过 `state` 字段跟踪当前阶段。
- **上下文保存**：局部变量会被提升为状态机的字段，确保异步操作恢复时能访问正确的值。
- **异常处理**：如果异步操作抛出异常，状态机会捕获并传递给 `Task`。
- **线程池调度**：通过 `TaskScheduler`，状态机可以在合适的线程上恢复执行（例如 UI 线程或线程池线程）。

---

### 5. **为什么说它是语法糖？**
- **隐藏复杂性**：开发者无需手动编写状态机、回调或 `Task.ContinueWith`。
- **同步代码风格**：用 `await` 代替回调，代码结构更清晰。
- **编译器自动生成**：所有状态机逻辑由编译器生成，开发者只需关注业务逻辑。

---

### 6. **验证状态机存在的方法**
1. **反编译工具**：使用 ILSpy 或 dotPeek 查看 `async` 方法的 IL 代码，会发现生成的状态机类。
2. **性能分析**：状态机的创建和调度会带来微小开销，因此在极端高性能场景需谨慎使用异步。

---

注意：在方法前加上async关键字不会改变函数的返回值类型：方法的返回值类型（如 Task、Task<T> 或 void）在方法签名中显式声明，与 async 无关。编译器会根据返回值类型自动生成对应的异步逻辑。

### 总结
C# 的 async + await 会将方法包装成状态机，await类似于检查点，MoveNext 方法会被底层调用，从而切换状态。开发者可以专注于业务逻辑，而状态机负责管理异步操作的暂停、恢复、上下文保存和异常处理。这种设计是 C# 异步编程模型的核心机制之一。

### 3. async Task与async void

#### 3.1 async Task

1. 返回值依旧是 Task 类型，但是在其中可以使用`await`关键字
2. 在其中写返回值可以直接写 Task<T> 中的 T 类型，不用包装成 Task<T>，例如：

```csharp
class Demo
{
    // 以下两种都是符合要求的返回值
    public Task FooAsync() //无async关键字，返回值必须是Task类型
    {
        await Task.Delay(1);
        return Task.Run(() => { });
    }

    public async Task FooAsync2()
    {
        await Task.Delay(1);
        return; //可以不需要返回值
    }
}
```

`async`额外的便利：直接返回类型，而无需再new一个Task。

#### 3.2 async void

在C#异步编程中，`async void`和`async Task`一样，也会被编译成一个状态机，以下是它们的核心区别和适用场景：

---

### **1. 核心区别**
| **特性**               | `async Task`                          | `async void`                          |
|-------------------------|---------------------------------------|---------------------------------------|
| **返回值**              | 返回 `Task` 对象，表示异步操作的状态    | 无返回值（类似 `void` 方法）           |
| **异常处理**            | 异常会被包装在 `Task` 中，可通过 `await` 捕获 | 异常会直接抛出到同步上下文，可能导致程序崩溃 |
| **可等待性**            | 支持 `await` 等待完成                  | 无法被 `await` 等待                    |
| **设计意图**            | 表示一个可观察、可等待的异步操作         | 主要用于事件处理器（如按钮点击事件）     |

---

### **2. 详细对比**

#### **(1) 返回值与可等待性**
- **`async Task`**  
  - 返回一个 `Task` 对象，调用方可以通过 `await` 等待异步操作完成。  
  - 示例：  
    ```csharp
    async Task DoWorkAsync()
    {
        await Task.Delay(1000);
    }

    // 调用方可以等待
    await DoWorkAsync();
    ```

- **`async void`**  
  - 不返回任何值，调用方无法等待其完成，也无法知道异步操作是否成功。  
  - 示例：  
    ```csharp
    async void HandleButtonClick()
    {
        await Task.Delay(1000);
    }

    // 调用方无法等待，也无法捕获异常
    HandleButtonClick(); // 直接触发，无法跟踪状态
    ```

---

#### **(2) 异常处理**
- **`async Task`**  
  - 异常会被包装在返回的 `Task` 中，调用方通过 `await` 或检查 `Task.Exception` 捕获异常。  
  - 示例：  
    ```csharp
    async Task DoWorkAsync()
    {
        throw new InvalidOperationException("Error!");
    }

    try
    {
        await DoWorkAsync();
    }
    catch (Exception ex)
    {
        // 异常被捕获
        Console.WriteLine(ex.Message);
    }
    ```

- **`async void`**  
  - 异常会直接抛到当前同步上下文（如UI线程），若未处理，可能导致应用程序崩溃。  
  - 示例：  
    ```csharp
    async void HandleButtonClick()
    {
        throw new InvalidOperationException("Error!");
    }

    // 调用后，异常无法被捕获，可能导致崩溃
    HandleButtonClick();
    ```

事件处理中，更推荐的做法是使用 **Func<Task>**取代Action，例如：

```csharp
var demo = new Demo();
demo.OnClickBtn1 += FooAsync;

private async void FooAsync()
{
    //...
}

private class Demo
{
    public event Action OnClickBtn1;
}
```

```csharp
var demo = new Demo();
demo.OnClickBtn1 += FooAsync;

private async Task FooAsync()
{
    //...
    return;
}

private class Demo
{
    public event Func<Task> OnClickBtn1;
}
```

---

#### **(3) 使用场景**
- **`async Task`**  
  - 适用于需要等待或观察结果的异步操作（如数据加载、网络请求）。  
  - 是异步编程的推荐方式，符合“可组合性”原则。  

- **`async void`**  
  - **仅用于事件处理器**（如按钮点击、UI事件），因为这些方法本身无法返回 `Task`。  
  - 示例：  
    ```csharp
    // WinForms 或 WPF 中的按钮点击事件
    private async void Button_Click(object sender, EventArgs e)
    {
        await LoadDataAsync();
    }
    ```

---

### **3. 关键注意事项**
1. **避免 `async void`**  
   - 除非在事件处理器中，否则永远不要使用 `async void`。  
   - `async void` 会导致异常无法被捕获，增加调试难度。  

2. **对 `async void` 的异常处理**  
   - 如果必须使用 `async void`，需在方法内部处理所有异常：  
     ```csharp
     async void RiskyMethod()
     {
         try
         {
             await Task.Delay(1000);
             throw new Exception("Error!");
         }
         catch (Exception ex)
         {
             // 记录异常，防止崩溃
             Logger.Log(ex);
         }
     }
     ```

3. **设计规范**  
   - 遵循 C# 异步编程最佳实践：  
     - 所有异步方法返回 `Task` 或 `Task<T>`。  
     - 只有事件处理器使用 `async void`。  

---

### **4. 总结**
| **场景**               | `async Task`                          | `async void`                          |
|-------------------------|---------------------------------------|---------------------------------------|
| **返回值**              | 返回 `Task`，可等待                    | 无返回值，无法等待                     |
| **异常处理**            | 通过 `await` 捕获                      | 可能导致未处理异常                      |
| **适用场景**            | 通用异步操作                           | 事件处理器（如UI事件）                  |
| **代码健壮性**          | 高                                    | 低（需谨慎使用）                        |

---

### **代码示例对比**
```csharp
// 正确用法：async Task
async Task LoadDataAsync()
{
    await Task.Delay(1000);
    // 其他异步操作
}

// 错误用法：async void（非事件处理器）
async void RiskyOperation()
{
    await Task.Delay(1000);
    throw new Exception("Unhandled!");
}

// 事件处理器中的合法用法
private async void Button_Click(object sender, EventArgs e)
{
    try
    {
        await LoadDataAsync();
    }
    catch (Exception ex)
    {
        MessageBox.Show($"Error: {ex.Message}");
    }
}
```

---

**总结**：`async void`和`async Task`一样会被包装成状态机，，但缺少记录状态的 Task 对象，因此无法调用的时候等待这个异步方法，无法获取异步任务的状态（Result等），也无法聚合异常（Aggregate Exception），即从异步方法外捕获异常，需要谨慎处理异常，几乎只用于对于事件的注册，实际项目中尽量不要使用。

---

### 4. 异步编程具有传染性（Contagious）
