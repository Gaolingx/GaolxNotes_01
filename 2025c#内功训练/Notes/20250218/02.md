# C#多线程与异步编程（二）

## 二、C#中常见的多线程实现方式

### 2.1 内置多线程方法

#### 2.1.1 Parallel 类：For、ForEach、Invoke

定义：提供对并行循环和区域的支持。

Parallel.For 方法执行 `for` 循环，其中可能会并行运行迭代。

用法：

```csharp
Parallel.For(开始索引, 结束索引, 每个迭代调用一次的委托);
```

#### 2.1.2 PLINQ：AsParallel、AsSequential、AsOrdered

定义：并行 LINQ (PLINQ) 是语言集成查询 (LINQ) 模式的并行实现。 PLINQ 将整套 LINQ 标准查询运算符实现为 System.Linq 命名空间的扩展方法，并提供适用于并行操作的其他运算符。 PLINQ 将 LINQ 语法的简洁和可靠性与并行编程的强大功能结合在一起。

ParallelEnumerable.AsParallel 方法，启用查询的并行化，如果需要保证执行顺序，可以在后面加一个 AsOrdered保证顺序

---

我们以Paraller.For 和 ParallelEnumerable.AsParallel 为例，使用 Thread.Sleep 模拟耗时操作，使用 Stopwatch查看执行耗时，看看相较于for循环的性能的提升。

运行以下代码，观察输出结果和耗时。

```csharp
using NUnit.Framework;
using System.Diagnostics;

namespace TestThreadSecurity
{
    internal class Parallelfor
    {
        /// <summary>
        /// 1. Sequential
        /// </summary>
        [Test]
        public void TestSequential()
        {
            var inputs = Enumerable.Range(1, 20).ToArray();

            int HeavyJob(int input)
            {
                Thread.Sleep(300);
                return input;
            }

            var sw = Stopwatch.StartNew();

            var forOutputs = new int[inputs.Length];
            for (int i = 0; i < inputs.Length; i++)
            {
                forOutputs[i] = HeavyJob(inputs[i]);
            }

            Console.WriteLine($"Elapsed time: {sw.ElapsedMilliseconds}");
            PrintArray(forOutputs);
        }

        /// <summary>
        /// 2. Parallel
        /// </summary>
        [Test]
        public void TestParallel()
        {
            var inputs = Enumerable.Range(1, 20).ToArray();

            int HeavyJob(int input)
            {
                Thread.Sleep(300);
                return input;
            }

            var sw = Stopwatch.StartNew();

            var parallelOutputs = new int[inputs.Length];

            // Parallel.For(开始索引, 结束索引, 每个迭代调用一次的委托);
            Parallel.For(0, inputs.Length, i =>
            {
                parallelOutputs[i] = HeavyJob(inputs[i]);
            });

            Console.WriteLine($"Elapsed time: {sw.ElapsedMilliseconds}");
            PrintArray(parallelOutputs);
        }

        /// <summary>
        /// 3. PLinq
        /// </summary>
        [Test]
        public void TestPLinq()
        {
            var inputs = Enumerable.Range(1, 20).ToArray();

            int HeavyJob(int input)
            {
                Thread.Sleep(300);
                return input;
            }

            var sw = Stopwatch.StartNew();

            var plinqOutputs = inputs.AsParallel().Select(HeavyJob).ToArray();

            Console.WriteLine($"Elapsed time: {sw.ElapsedMilliseconds}");
            PrintArray(plinqOutputs);
        }

        private void PrintArray<T>(T[] values)
        {
            string output = string.Join(", ", values);
            Console.WriteLine(output);
        }
    }
}

```

Sequential 执行速度最慢，约6s后执行完成，而 Parallel For 和 PLinq 执行速度约310ms，可以看出当使用并行的方式去运行for或者linq，可以大大提高迭代速度，但是顺序是不能被保证的。

### 2.2 线程（Thread）

#### 2.2.1 Thread 类

定义：创建和控制线程，设置其优先级并获取其状态。

##### 1. 线程的创建

代码：

```csharp
void ThreadStart(object? obj) { }
// 1. 创建 Thread 实例，并传入 ThreadStart 委托 
Thread thread = new Thread(ThreadStart);
// 2. 调用 Thread.Start 方法，还可以传参
thread.Start();
// 3. 还可以配置线程，如是否为后台线程
thread.IsBackground = true;
```

##### 2. 线程的终止

1. 调用 `Thread.Join` 方法，等待线程的结束
在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止。

2. 调用 `Thread.Interrupt` 方法，中断正在运行的子线程
中断处于 WaitSleepJoin 线程状态的线程。

注：不建议使用 `Thread.Abort` 终止线程，原因如下：

1. 使用 Abort 方法来强制终止线程可能导致一些严重的问题，包括资源泄漏和不可预测的行为。
2. 较新版本的 .NET 中如果使用这个方法，会报 `PlatformNotSupportedException` （Thread.Abort is not supported and throws PlatformNotSupportedException.），说明该方法已经过时，无法使用。

推荐使用 `Thread.Interrupt` 或 `CancellationToken` 作为替代。

代码：

```csharp
/// <summary>
/// 4. 线程终止
/// </summary>

[Test]
public void TestStopThread()
{
    var thread = new Thread((object? obj) =>
    {
        DoJobBackground();
    })
    {
        IsBackground = true,
        Priority = ThreadPriority.Normal,
    };

    var thread2 = new Thread((object? obj) =>
    {
        DoJobBackground();
    })
    {
        IsBackground = true,
        Priority = ThreadPriority.Normal,
    };

    thread.Start();
    Console.WriteLine($"Running in main thread, id: {Thread.CurrentThread.ManagedThreadId}");
    thread.Join(); // 会导致主线程阻塞，直到子线程的任务完成
    Console.WriteLine("Job 1 Done!");

    Console.WriteLine("===================");
    thread2.Start();
    Console.WriteLine($"Running in main thread, id: {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(3500);
    thread2.Interrupt(); // 立即结束线程
    thread2.Join();
    Console.WriteLine("Job 2 Done!");
}

private void DoJobBackground()
{
    try
    {
        int threadId = Thread.CurrentThread.ManagedThreadId;
        for (int i = 0; i < 10; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Running in sub thread: " + i + ", thread id: " + threadId);
        }
        Console.WriteLine("Sub thread task finished !");
    }
    catch (ThreadInterruptedException)
    {
        Console.WriteLine("Thread has been interrupted !");
    }
}
```

运行结果如下：

从中我们发现，Thread.Join 尽管可以等待线程的结束，但是会导致主线程的阻塞，即主线程这个时候必须等待这个new出来的子线程跑完才能回到主线程继续执行，我们可以通过调用 Thread.Interrupt 方法，中断线程的执行，此时会会在相应线程中抛出 `ThreadInterruptedException` ，

注：调用 `Thread.Interrupt` 方法，如果线程中包含一个 while(true) 循环，那么需要保证包含等待方法，如IO操作，`Thread.Sleep` 等。

##### 3. 线程的挂起与恢复

我们可以使用 `Thread.Suspend` 以及 `Thread.Resume` ，较新版本的 .NET 中，这两个方法已经被标记为 [Obsolete] ，且调用会报错，推荐使用锁、信号量等方式实现这一逻辑。

##### 4. 线程的超时

### 2.3 线程池（ThreadPool）

### 2.4 异步编程（async Task）