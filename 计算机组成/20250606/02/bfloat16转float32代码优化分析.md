# bfloat16è½¬float32ä»£ç ä¼˜åŒ–åˆ†æ

### ğŸ§‘â€ğŸ’» User

è¿™æ®µä»£ç æœ‰ä»€ä¹ˆç”¨é€”ï¼Œæœ‰æ²¡æœ‰ä½¿ç”¨ä¸€äº›ä¼˜åŒ–æŠ€å·§ï¼Ÿ

```cpp
/**
 * Converts brain16 to float32.
 *
 * The bfloat16 floating point format has the following structure:
 *
 *       â”Œsign
 *       â”‚
 *       â”‚   â”Œexponent
 *       â”‚   â”‚
 *       â”‚   â”‚      â”Œmantissa
 *       â”‚   â”‚      â”‚
 *       â”‚â”Œâ”€â”€â”´â”€â”€â”€â”â”Œâ”€â”´â”€â”€â”€â”
 *     0b0000000000000000 brain16
 *
 * Since bf16 has the same number of exponent bits as a 32bit float,
 * encoding and decoding numbers becomes relatively straightforward.
 *
 *       â”Œsign
 *       â”‚
 *       â”‚   â”Œexponent
 *       â”‚   â”‚
 *       â”‚   â”‚      â”Œmantissa
 *       â”‚   â”‚      â”‚
 *       â”‚â”Œâ”€â”€â”´â”€â”€â”€â”â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *     0b00000000000000000000000000000000 IEEE binary32
 *
 * For comparison, the standard fp16 format has fewer exponent bits.
 *
 *       â”Œsign
 *       â”‚
 *       â”‚  â”Œexponent
 *       â”‚  â”‚
 *       â”‚  â”‚    â”Œmantissa
 *       â”‚  â”‚    â”‚
 *       â”‚â”Œâ”€â”´â”€â”â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”
 *     0b0000000000000000 IEEE binary16
 *
 * @see IEEE 754-2008
 */
static inline float ggml_compute_bf16_to_fp32(ggml_bf16_t h) {
    union {
        float f;
        uint32_t i;
    } u;
    u.i = (uint32_t)h.bits << 16;
    return u.f;
}
```

---

### ğŸ¤– Assistant

è¿™æ®µä»£ç ç”¨äºå°† `bfloat16`ï¼ˆç®€ç§° `bf16`ï¼‰æ ¼å¼çš„æ•°æ®é«˜æ•ˆåœ°è½¬æ¢ä¸ºæ ‡å‡†çš„ `float32`ï¼ˆå•ç²¾åº¦æµ®ç‚¹æ•°ï¼‰ã€‚ä»¥ä¸‹æ˜¯å¯¹å…¶ç”¨é€”å’Œä¼˜åŒ–æŠ€å·§çš„è¯¦ç»†åˆ†æï¼š

---

### **æ ¸å¿ƒç”¨é€”**
1. **æµ®ç‚¹æ•°æ ¼å¼è½¬æ¢**  
   - `bfloat16` æ˜¯ä¸“ä¸ºæœºå™¨å­¦ä¹ è®¾è®¡çš„é«˜æ•ˆæµ®ç‚¹æ ¼å¼ï¼ˆ1ä½ç¬¦å· + 8ä½æŒ‡æ•° + 7ä½å°¾æ•°ï¼‰ã€‚
   - å®ƒç‰ºç‰²äº†éƒ¨åˆ†ç²¾åº¦ï¼ˆå°¾æ•°ä½æ¯” `float16` æ›´å°‘ï¼‰ï¼Œä½†ä¿ç•™äº†ä¸ `float32` ç›¸åŒçš„æŒ‡æ•°èŒƒå›´ï¼Œé¿å…äº†æ•°å€¼æº¢å‡º/ä¸‹æº¢é—®é¢˜ã€‚
   - è¯¥å‡½æ•°å°† `bf16` çš„äºŒè¿›åˆ¶ä½ç›´æ¥æ‰©å±•ä¸º `float32` æ ¼å¼ï¼Œä¿æŒæ•°å€¼çš„æ•°å­¦æ„ä¹‰ä¸å˜ã€‚

2. **åº”ç”¨åœºæ™¯**  
   å¸¸è§äºæ·±åº¦å­¦ä¹ æ¡†æ¶ï¼ˆå¦‚TensorFlow/PyTorchï¼‰ä¸­ï¼Œç”¨äºåŠ é€Ÿç¥ç»ç½‘ç»œè®¡ç®—ï¼ˆ`bf16` å‡å°‘å†…å­˜å ç”¨å’Œå¸¦å®½ï¼Œè®¡ç®—æ—¶è½¬æ¢ä¸º `float32` ä¿éšœç²¾åº¦ï¼‰ã€‚

---

### **ä¼˜åŒ–æŠ€å·§**
1. **é›¶æ‹·è´ä½æ“ä½œ**  
   ```c
   u.i = (uint32_t)h.bits << 16;  // å·¦ç§»16ä½å¡«å……ä½16ä½ä¸º0
   ```
   - **åŸç†**ï¼š`bf16` å’Œ `float32` çš„**ç¬¦å·ä½ä¸æŒ‡æ•°ä½å®Œå…¨å¯¹é½**ï¼ˆè§ä¸‹å›¾ï¼‰ï¼Œåªéœ€å°† `bf16` çš„16ä½ç§»åˆ° `float32` çš„é«˜16ä½ï¼Œä½16ä½è¡¥é›¶ã€‚
   - **ä¼˜åŠ¿**ï¼šé¿å…å¤æ‚çš„ç®—æœ¯è¿ç®—æˆ–æ¡ä»¶åˆ¤æ–­ï¼Œä»…éœ€ä¸€æ¬¡ç§»ä½æ“ä½œã€‚

2. **è”åˆä½“ï¼ˆUnionï¼‰ç±»å‹åŒå…³**  
   ```c
   union { float f; uint32_t i; } u;
   u.i = ... ;  // å†™å…¥æ•´æ•°
   return u.f;  // è¯»å–æµ®ç‚¹æ•°
   ```
   - **åŸç†**ï¼šé€šè¿‡ `union` ç›´æ¥å¤ç”¨åŒä¸€å—å†…å­˜ï¼Œå°†æ•´æ•°ä½æ¨¡å¼é‡æ–°è§£é‡Šä¸ºæµ®ç‚¹æ•°ã€‚
   - **ä¼˜åŠ¿**ï¼šé¿å…é¢å¤–çš„å†…å­˜æ‹·è´æˆ–è½¬æ¢æŒ‡ä»¤ï¼ˆå¦‚ `memcpy`ï¼‰ï¼Œç¼–è¯‘åé€šå¸¸å¯¹åº”å•æ¡æ±‡ç¼–æŒ‡ä»¤ã€‚

3. **å†…è”å‡½æ•°ï¼ˆ`inline`ï¼‰**  
   - å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€ï¼Œé€‚åˆé«˜é¢‘è°ƒç”¨çš„å°å‹æ“ä½œã€‚

---

### **æ ¼å¼å¯¹é½åŸç†**
```
         bf16 (16ä½)       |  float32 (32ä½)
[ç¬¦å·][æŒ‡æ•°][å°¾æ•°]          [ç¬¦å·][æŒ‡æ•°][å°¾æ•°]        
0 0000000 0000000   ->  0 0000000 0000000 0000000000000000
       â†‘
       å·¦ç§»16ä½åï¼Œç¬¦å·/æŒ‡æ•°å¯¹é½ï¼Œå°¾æ•°é«˜ä½å¯¹é½ï¼Œä½ä½è¡¥é›¶
```
- **å°¾æ•°å¤„ç†**ï¼š`bf16` çš„7ä½å°¾æ•°ç›´æ¥æ”¾å…¥ `float32` å°¾æ•°çš„é«˜7ä½ï¼Œä½16ä½ä¸ºé›¶ã€‚ç”±äºå°¾æ•°ç²¾åº¦æŸå¤±å·²åœ¨ `bf16` ä¸­å‘ç”Ÿï¼Œè¡¥é›¶ä¸ä¼šå¼•å…¥é¢å¤–è¯¯å·®ã€‚
- **ç‰¹æ®Šå€¼å…¼å®¹**ï¼šNaNã€æ— ç©·å¤§ç­‰ç‰¹æ®Šå€¼å› æŒ‡æ•°ä½å¯¹é½è€Œè‡ªåŠ¨æ­£ç¡®å¤„ç†ã€‚

---

### **æ€§èƒ½å¯¹æ¯”**
- **å¸¸è§„æ–¹æ³•**ï¼šéœ€åˆ†ç¦»ç¬¦å·/æŒ‡æ•°/å°¾æ•°ï¼Œå†ç»„åˆåˆ° `float32`ï¼ˆå¤šæ¬¡ä½æ“ä½œ+æ¡ä»¶åˆ¤æ–­ï¼‰ã€‚
- **æœ¬æ–¹æ³•**ï¼š**ä»…éœ€1æ¬¡ç§»ä½+1æ¬¡å†…å­˜è§£é‡Š**ï¼Œæè‡´ç²¾ç®€ã€‚

---

### **æ³¨æ„äº‹é¡¹**
1. **å­—èŠ‚åºä¾èµ–**  
   ä»£ç å‡è®¾å¹³å°ä¸ºå°ç«¯åºï¼ˆLittle-Endianï¼‰ï¼Œè‹¥åœ¨å¤§ç«¯åºï¼ˆBig-Endianï¼‰ç³»ç»Ÿéœ€è°ƒæ•´ã€‚
2. **éè§„æ ¼åŒ–æ•°ï¼ˆDenormalsï¼‰**  
   ç›´æ¥ç§»ä½å¯èƒ½å¯¼è‡´éƒ¨åˆ†æå°æ•°å€¼å¤„ç†å¼‚å¸¸ï¼Œä½† `bf16` è®¾è®¡ä¸Šé€šå¸¸å¿½ç•¥æ­¤ç±»åœºæ™¯ã€‚
3. **æ ‡å‡†åˆè§„æ€§**  
   ä½¿ç”¨ `union` è¿›è¡Œç±»å‹åŒå…³åœ¨C99ä¸­åˆæ³•ï¼Œä½†éƒ¨åˆ†ä¸¥æ ¼ç¼–è¯‘å™¨ï¼ˆå¦‚ `gcc -fstrict-aliasing`ï¼‰å¯èƒ½è­¦å‘Šã€‚å¯é€šè¿‡ `-fno-strict-aliasing` æˆ– `memcpy` æ›¿ä»£ï¼ˆç°ä»£ç¼–è¯‘å™¨èƒ½ä¼˜åŒ–ä¸ºç›¸åŒæŒ‡ä»¤ï¼‰ã€‚

---

### **æ€»ç»“**
æ­¤ä»£ç ä»¥**æœ€å°ä»£ä»·**å®Œæˆ `bf16â†’float32` è½¬æ¢ï¼Œæ ¸å¿ƒä¼˜åŒ–åœ¨äºï¼š
1. åˆ©ç”¨æ ¼å¼å¯¹é½ç‰¹æ€§ï¼Œç”¨ç§»ä½æ“ä½œæ›¿ä»£å¤æ‚è§£ç ã€‚
2. é€šè¿‡ `union` å®ç°é›¶æ‹·è´ç±»å‹è½¬æ¢ã€‚
3. å†…è”å£°æ˜é¿å…è°ƒç”¨å¼€é”€ã€‚

é€‚ç”¨äºé«˜æ€§èƒ½è®¡ç®—åœºæ™¯ï¼ˆå¦‚GPU/TPUæ¨ç†ï¼‰ï¼Œæ˜¯ç¡¬ä»¶åŠ é€Ÿåº“ä¸­çš„å¸¸è§ä¼˜åŒ–æ‰‹æ®µã€‚

---

### ğŸ§‘â€ğŸ’» User

è¿™æ®µä»£ç æœ‰ä»€ä¹ˆç”¨é€”ï¼Œæœ‰æ²¡æœ‰ä½¿ç”¨ä¸€äº›ä¼˜åŒ–æŠ€å·§ï¼Ÿ

```cpp
/**
 * Converts float32 to brain16.
 *
 * This is binary identical with Google Brain float conversion.
 * Floats shall round to nearest even, and NANs shall be quiet.
 * Subnormals aren't flushed to zero, except perhaps when used.
 * This code should vectorize nicely if using modern compilers.
 */
static inline ggml_bf16_t ggml_compute_fp32_to_bf16(float s) {
    ggml_bf16_t h;
    union {
        float f;
        uint32_t i;
    } u;
    u.f = s;
    if ((u.i & 0x7fffffff) > 0x7f800000) { /* nan */
        h.bits = (u.i >> 16) | 64; /* force to quiet */
        return h;
    }
    h.bits = (u.i + (0x7fff + ((u.i >> 16) & 1))) >> 16;
    return h;
}
```

---

### ğŸ¤– Assistant

è¿™æ®µä»£ç å®ç°äº†å°† `float32`ï¼ˆå•ç²¾åº¦æµ®ç‚¹æ•°ï¼‰è½¬æ¢ä¸º `bfloat16`ï¼ˆBF16ï¼‰æ ¼å¼çš„åŠŸèƒ½ï¼Œä¸»è¦ç”¨äºæ·±åº¦å­¦ä¹ åœºæ™¯ä¸­å‡å°‘å†…å­˜å ç”¨ï¼ŒåŒæ—¶åŒ…å«äº†å‡ é¡¹å…³é”®ä¼˜åŒ–ï¼š

---

### **æ ¸å¿ƒç”¨é€”**
1. **å†…å­˜ä¼˜åŒ–**  
   - å°† 32 ä½æµ®ç‚¹æ•°å‹ç¼©ä¸º 16 ä½ `bfloat16`ï¼ˆä¿ç•™ 8 ä½æŒ‡æ•° + 7 ä½å°¾æ•°ï¼‰
   - é€‚ç”¨äºæ·±åº¦å­¦ä¹ æ¨¡å‹ï¼ˆå¦‚ TensorFlow/PyTorchï¼‰ï¼Œåœ¨ä¿æŒæ•°å€¼èŒƒå›´çš„å‰æä¸‹å‡å°‘ 50% å†…å­˜å ç”¨

2. **ç‰¹æ®Šå€¼å¤„ç†**  
   - æ­£ç¡®å¤„ç† `NaN`ï¼ˆéæ•°å­—ï¼‰ï¼Œå¼ºåˆ¶è½¬ä¸ºé™é»˜ NaNï¼ˆQuiet NaNï¼‰
   - æ”¯æŒéè§„æ ¼åŒ–æ•°ï¼ˆSubnormalsï¼‰ï¼Œä¸å¼ºåˆ¶åˆ·æ–°ä¸ºé›¶

---

### **å…³é”®ä¼˜åŒ–æŠ€å·§**
#### 1. **è”åˆä½“ç±»å‹åŒå…³ (Type Punning)**
```c
union { float f; uint32_t i; } u;
u.f = s; // ç›´æ¥å¤ç”¨å†…å­˜é¿å…æ‹·è´
```
- **ä¼˜åŠ¿**ï¼šé¿å… `memcpy`ï¼Œç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸ºå•æ¡æŒ‡ä»¤

#### 2. **NaN å¤„ç†ä¼˜åŒ–**
```c
if ((u.i & 0x7fffffff) > 0x7f800000) { /* nan */
    h.bits = (u.i >> 16) | 64; // é™é»˜ NaN æ ‡è®°
}
```
- **æŠ€å·§**ï¼š
  - `0x7fffffff`ï¼šæ¸…é™¤ç¬¦å·ä½ï¼ˆä¿ç•™æŒ‡æ•°+å°¾æ•°ï¼‰
  - `0x7f800000`ï¼šIEEE 754 ä¸­æµ®ç‚¹æ•°æ— ç©·å¤§çš„ä½æ¨¡å¼
  - **æ¡ä»¶**ï¼šå½“æ•°å€¼èŒƒå›´è¶…è¿‡æ— ç©·å¤§æ—¶åˆ¤å®šä¸º NaN
  - `| 64`ï¼šè®¾ç½®å°¾æ•°æœ€é«˜ä½ (0x40)ï¼Œç¡®ä¿è½¬ä¸ºé™é»˜ NaN

#### 3. **èˆå…¥åˆ°æœ€è¿‘å¶æ•° (Round to Nearest Even)**
```c
h.bits = (u.i + (0x7fff + ((u.i >> 16) & 1))) >> 16;
```
- **ä¼˜åŒ–åŸç†**ï¼š
  - `0x7fff`ï¼šç›¸å½“äº 0.5 ULPï¼ˆUnit in Last Placeï¼‰
  - `((u.i >> 16) & 1`ï¼šæ£€æµ‹æœ€ä½æœ‰æ•ˆä½ï¼ˆå¥‡å¶åˆ¤æ–­ï¼‰
- **ä½œç”¨**ï¼š
  - å½“æˆªæ–­éƒ¨åˆ† > 0.5 ULP æ—¶è¿›ä½
  - å½“æˆªæ–­éƒ¨åˆ† = 0.5 ULP æ—¶å‘æœ€è¿‘çš„å¶æ•°èˆå…¥
- **ä¼˜åŠ¿**ï¼šå•æ¡è¡¨è¾¾å¼å®ç°æ ‡å‡†èˆå…¥ï¼Œé¿å…åˆ†æ”¯

#### 4. **å‘é‡åŒ–å‹å¥½è®¾è®¡**
- æ— å¤æ‚åˆ†æ”¯ï¼ˆä»… 1 ä¸ª NaN æ£€æŸ¥ï¼‰
- çº¯æ•´æ•°è¿ç®—ï¼ˆç°ä»£ CPU/GPU å¯å¹¶è¡Œå¤„ç†ï¼‰
- æ³¨é‡Šæ˜ç¡®æç¤ºç¼–è¯‘å™¨ä¼˜åŒ–ï¼š`This code should vectorize nicely`

#### 5. **å†…è”å‡½æ•°**
- `static inline` å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€

---

### **å·¥ä½œæµç¨‹**
1. **NaN æ£€æµ‹**  
   - æ£€æµ‹æŒ‡æ•°å…¨ 1 ä¸”å°¾æ•°é 0 â†’ åˆ¤å®šä¸º NaN
   - å¼ºåˆ¶è®¾ç½®å°¾æ•°æœ€é«˜ä½ç”Ÿæˆé™é»˜ NaN

2. **å¸¸è§„å€¼è½¬æ¢**  
   ```mermaid
   graph LR
   A[float32] --> B[æ·»åŠ èˆå…¥åç§»]
   B --> C{æœ€ä½ä½å¥‡å¶åˆ¤æ–­}
   C -->|å¥‡æ•°| D[+0x8000]
   C -->|å¶æ•°| E[+0x7FFF]
   D & E --> F[å³ç§»16ä½]
   F --> G[bfloat16]
   ```

---

### **æ€§èƒ½ä¼˜åŠ¿å¯¹æ¯”**
| **æ–¹æ³•**              | æŒ‡ä»¤æ•° | åˆ†æ”¯ | å‘é‡åŒ– |
|----------------------|-------|------|--------|
| æ ‡å‡†åº“è½¬æ¢            | é«˜    | å¤š   | å›°éš¾   |
| **æœ¬ä»£ç **           | æä½  | 1 ä¸ª | ä¼˜ç§€   |

---

### **æ³¨æ„äº‹é¡¹**
1. **å­—èŠ‚åºä¾èµ–**  
   å‡è®¾å°ç«¯åºï¼ˆLittle-Endianï¼‰ç³»ç»Ÿï¼Œéœ€ç¡®ä¿è¿è¡Œç¯å¢ƒå…¼å®¹

2. **éè§„æ ¼åŒ–æ•°å¤„ç†**  
   ä¸ä¸»åŠ¨åˆ·æ–°éè§„æ ¼åŒ–æ•°ï¼ˆSubnormalsï¼‰ï¼Œä½†ç¡¬ä»¶æ”¯æŒå¯èƒ½å¯¼è‡´éšå¼åˆ·æ–°

3. **èˆå…¥ç²¾åº¦**  
   ä¸¥æ ¼éµå¾ª IEEE 754 çš„ "round to nearest even" æ ‡å‡†

---

### **æ€»ç»“**
æ­¤ä»£ç é€šè¿‡ä¸‰é¡¹æ ¸å¿ƒä¼˜åŒ–å®ç°é«˜æ•ˆè½¬æ¢ï¼š
1. **ä½è¿ç®—æ›¿ä»£æµ®ç‚¹æ“ä½œ**ï¼šç”¨æ•´æ•°ç®—æœ¯ç›´æ¥æ“ä½œä½æ¨¡å¼
2. **æ™ºèƒ½èˆå…¥**ï¼šå•è¡¨è¾¾å¼å®ç° `(value + 0.5 ULP + parity)` çš„èˆå…¥ç­–ç•¥
3. **é™é»˜ NaN ç”Ÿæˆ**ï¼šé€šè¿‡ `| 64` å¿«é€Ÿè®¾ç½®é™é»˜æ ‡å¿—

é€‚ç”¨äºéœ€è¦é«˜é¢‘æ‰¹é‡è½¬æ¢çš„åœºæ™¯ï¼ˆå¦‚ç¥ç»ç½‘ç»œæ¨ç†ï¼‰ï¼Œåœ¨ä¿æŒç²¾åº¦çš„åŒæ—¶æœ€å¤§åŒ–ç¡¬ä»¶åˆ©ç”¨ç‡ã€‚