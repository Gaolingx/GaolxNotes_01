# 渲染图技术解决传统渲染问题

## Question 1

传统的渲染流程存在以下诸多问题，
1. 强耦合：各个系统之间不可能完全独立，一个渲染系统需要的资源（Buffer，RenderTarget等）可能会依赖于另外一个渲染系统，各个系统之间的相互调用的情况非常多。这样有什么问题呢？我们在维护的时候，可能改了一个系统，那么其他很多系统的地方都得改。同时，随着系统越来越复杂，耦合性也会越来越紧密，代码的行数就会飞速增长。
2. 资源的显示定义：我们在前文中已经讲到，我们程序员是需要对资源进行手动管理的。什么时候申请资源，什么时候实际分配资源、什么时候回收资源，统统都得程序员自己定义。
3. 显式即时模式呈现：我们在渲染的时候，是采取即时渲染的策略，这是一种“说干就干”的策略（我自己的理解来看）。只要程序的指令轮到我了，那我就去找我需要的资源，然后马上开始执行。
4. 扩展的局限性：程序的执行完全是按照我们程序编写的顺序进行执行的，当程序运行的时候，渲染流程就已经固定死了，如果要想再调整渲染策略，就得改代码，然后再进行编译执行，难以进行扩展与渲染流程的自定义配置。
5. 难以Debug：游戏引擎的代码成十万上百万行，一个bug可能就得让人找的崩溃，更别说这些系统之间还存在极强的耦合性，这样的代码难以进行维护。

Render Graph提出的背景和目标是什么？

## Answer 1

Render Graph（渲染图）技术的提出，正是为了解决传统渲染流程中存在的上述问题。其背景和目标可以概括为以下几个关键点：

---

### **提出的背景**
1. **复杂项目需求驱动**  
   随着现代游戏和图形应用对画面质量、实时性和扩展性的要求越来越高，传统硬编码的渲染流程难以应对动态光照、后处理组合、多Pass渲染等复杂需求，亟需一种更灵活、可维护的方案。

2. **硬件资源管理困境**  
   GPU资源（如RenderTarget、Buffer）的创建、复用和回收需要精细控制，传统手动管理模式易导致内存浪费或竞争（如Frame Buffer的反复分配），尤其在多线程渲染中问题加剧。

3. **解耦与模块化的行业趋势**  
   现代引擎设计强调“高内聚、低耦合”，而传统强耦合的渲染系统阻碍了功能模块的独立开发和测试（例如抗锯齿与阴影系统互相依赖）。

---

### **核心目标**
1. **解耦渲染逻辑**  
   - **依赖显式化**：通过图结构（Graph）抽象渲染流程，将每个渲染阶段（Pass）定义为节点，资源依赖关系定义为边，实现逻辑解耦。  
   - **独立开发**：不同Pass（如阴影、光照、后处理）可独立设计，仅通过资源接口交互，避免代码级耦合。

2. **自动化资源管理**  
   - **生命周期管理**：Render Graph自动推导资源的创建、复用和销毁时机，例如跨帧复用中间纹理，减少内存峰值。  
   - **按需分配**：仅在Pass实际需要时分配资源，避免传统模式中“预先分配所有可能用到的资源”导致的浪费。

3. **声明式渲染流程**  
   - **延迟执行**：从传统的“即时模式”（Immediate Mode）转为“声明模式”（Declarative），先构建完整的渲染图，再由框架优化执行顺序（如合并Pass、调整资源屏障）。  
   - **跨平台优化**：根据目标硬件动态调整资源布局（如Vulkan的Memory Aliasing）。

4. **动态可扩展性**  
   - **运行时配置**：通过配置文件或脚本动态修改渲染流程（如开关SSR、调整抗锯齿策略），无需重新编译引擎。  
   - **模块化插件**：新渲染技术（如光线追踪Pass）可以插件形式接入现有渲染图，降低集成成本。

5. **调试与可视化支持**  
   - **依赖可视化**：渲染图可导出为图形化表示（如DOT语言），直观显示Pass和资源关系，辅助性能分析和Debug。  
   - **资源追踪**：提供工具链追踪特定资源（如GBuffer）的读写历史，快速定位数据错误或竞争条件。

---

### **典型案例**
- **Unreal Engine的RDG（Render Dependency Graph）**：通过显式声明Pass依赖，实现多线程渲染和资源复用，解决传统Deferred Shading架构的扩展性问题。  
- **Frostbite的Frame Graph**：支持动态插入Compute Pass优化光照计算，适应开放世界游戏的动态天气系统。  
- **Vulkan的Render Pass重设计**：从传统Render Pass转向更灵活的Dynamic Rendering，部分借鉴了Render Graph思想。

---

### **总结**
Render Graph的核心思想是**将渲染流程从“如何做”（How）转变为“做什么”（What）**，通过抽象化和自动化管理，解决传统流程的耦合性、资源冗余和扩展性瓶颈，同时为跨硬件优化和开发者协作提供基础设施。其本质是图形渲染领域向“数据驱动架构”演进的关键一步。

## Question 2

RenderGraph最亮眼的部分就是在Setup阶段，这个阶段也是它与传统渲染流程最不同的地方，能不能细说？

## Answer 2

RenderGraph 的 **Setup 阶段**（或称声明阶段）是其最核心的创新点，也是与传统渲染流程差异最大的部分。这一阶段的核心思想是 **“先声明，后执行”**，通过将渲染流程从传统的“即时指令式”转换为“声明式”，彻底改变了资源管理、Pass 依赖和流程控制的模式。以下是 Setup 阶段的详细解析：

---

### **1. Setup 阶段的核心步骤**
#### **(1) 声明资源（Resource Declaration）**
- **传统方式**：在代码中直接创建资源（如 `CreateTexture()`），手动管理生命周期（如 `ReleaseTexture()`），资源与具体渲染逻辑强绑定。
- **RenderGraph 方式**：
  - **抽象资源标识**：仅声明需要的资源类型和属性（如 `RG::TextureDesc::Create2D(1920x1080, RGBA8)`），无需立即分配内存。
  - **逻辑绑定而非物理绑定**：资源通过名称或句柄（如 `GBuffer::Albedo`）引用，实际内存分配由 RenderGraph 在后续阶段按需处理。
  - **示例代码**：
    ```cpp
    // 声明一个中间渲染目标
    auto& gbuffer = graph.DeclareTexture("GBuffer", Format::RGBA16F, width, height);
    ```

#### **(2) 构建渲染 Pass（Pass Registration）**
- **传统方式**：立即执行渲染指令（如 `DrawMesh()`），Pass 顺序硬编码在代码中，难以动态调整。
- **RenderGraph 方式**：
  - **Pass 定义**：每个 Pass 声明其输入输出资源和执行逻辑（Shader、参数等），但不立即执行。
  - **数据驱动**：Pass 之间通过资源依赖隐式定义顺序，而非显式调用。
  - **示例代码**：
    ```cpp
    graph.AddPass("ShadowMapPass", [&](RG::PassBuilder& pass) {
      pass.Write(shadowMap);  // 声明输出资源
      pass.SetExecute([=](RG::PassContext& ctx) {
        // 渲染阴影的具体逻辑（延迟执行）
      });
    });
    ```

#### **(3) 依赖分析与图构建（Dependency Resolution）**
- **关键算法**：通过资源读写关系，自动构建有向无环图（DAG），解决 Pass 之间的执行顺序。
  - **隐式排序**：若 Pass A 写入资源 X，Pass B 读取 X，则 A → B 的边自动生成。
  - **同步点插入**：自动处理资源状态转换（如 `TextureBarrier`），避免竞争条件。
- **优化策略**：
  - **Pass 合并**：无依赖关系的 Pass 可并行执行（如多线程提交）。
  - **资源别名（Aliasing）**：不同 Pass 的临时资源可复用同一内存区域（需生命周期不重叠）。

#### **(4) 资源生命周期推导**
- **按需分配**：仅在实际被引用的帧内分配资源，跨帧复用（如动态调整分辨率时自动重建）。
- **内存优化**：
  - **生存期分析**：通过资源的使用范围（哪些 Pass 读写），推导其创建和销毁时机。
  - **内存复用**：例如，后处理链中的中间纹理可复用同一块内存。

---

### **2. 与传统渲染流程的对比**
#### **执行模式**
| **维度**         | **传统流程**                     | **RenderGraph Setup 阶段**            |
|------------------|----------------------------------|--------------------------------------|
| **资源管理**      | 手动创建/销毁，硬编码在渲染逻辑中 | 声明式定义，自动推导生命周期          |
| **Pass 顺序**     | 代码顺序即执行顺序                | 依赖关系推导，可动态重排序            |
| **资源绑定**      | 直接操作 GPU 句柄（如 `ID3D12Resource*`） | 逻辑句柄（如 `TextureHandle`），物理绑定延迟到执行阶段 |
| **扩展性**        | 修改流程需改动代码并重新编译      | 动态插入/移除 Pass（如通过配置文件）   |

#### **典型问题解决**
- **强耦合问题**：Pass 仅依赖资源名称，不直接调用其他 Pass 的代码。
- **资源浪费**：通过生存期分析，自动复用内存（如上一帧的中间纹理可被下一帧的其他 Pass 复用）。
- **执行效率**：依赖图可优化执行顺序（如将屏障合并，减少 GPU 空闲）。

---

### **3. Setup 阶段的优势**
#### **(1) 声明式编程（Declarative Programming）**
- **关注点分离**：开发者只需声明“要什么”（如需要哪些资源、Pass 的功能），而非“如何实现”（如内存分配、Pass 顺序）。
- **示例**：声明一个后处理链：
  ```cpp
  graph.AddPass("BloomDownsample", ...);
  graph.AddPass("BloomUpsample", ...);
  graph.AddPass("Tonemapping", ...);
  ```
  RenderGraph 自动处理这些 Pass 的依赖关系和执行顺序。

#### **(2) 延迟决策（Deferred Decision Making）**
- **资源分配延迟**：直到所有 Pass 声明完成，RenderGraph 才全局分析资源需求，实现最小化内存分配。
- **跨 Pass 优化**：例如，若两个 Pass 使用相同格式的中间纹理但分辨率不同，可能自动插入缩放 Pass 而非分配两个纹理。

#### **(3) 动态适应性**
- **条件 Pass**：可根据运行时状态动态启用/禁用 Pass（如关闭 SSAO 时自动跳过相关资源分配）。
  ```cpp
  if (enableSSAO) {
    graph.AddPass("SSAO", ...);
  }
  ```
- **多平台适配**：在 Setup 阶段根据目标 GPU 调整资源格式（如移动端使用 ASTC 纹理）。

---

### **4. 实际案例：Unreal Engine 的 RDG**
Unreal Engine 的 **Render Dependency Graph (RDG)** 是 RenderGraph 的典型实现：
- **Setup 阶段**：开发者通过 `RDG_BEGIN_GRAPH()` 和 `RDG_ADD_PASS()` 声明 Pass 和资源。
- **执行优化**：
  - **自动合并资源屏障**：将多个 `TransitionResource()` 调用合并为最简形式。
  - **异步计算**：将 Compute Pass 与 Graphics Pass 并行提交到不同 GPU 队列。
- **内存节省**：在《堡垒之夜》中，RDG 通过资源复用减少了 30% 的显存占用。

---

### **总结**
RenderGraph 的 Setup 阶段通过 **声明式依赖构建** 和 **全局资源分析**，将传统渲染流程中的“硬编码决策”转变为“数据驱动的优化过程”。这种模式不仅解决了耦合和资源浪费问题，还为跨平台优化、动态渲染管线提供了基础设施，是实时图形领域向更高抽象层级演进的关键一步。

## Question 3

那pass在执行之前，都是需要向RenderGraph进行注册，提前进行声明，pass不能读或写没有声明的resource，这是为什么？

## Answer 3

在 RenderGraph 中，Pass 必须预先声明其读写资源且无法访问未声明的资源，这一设计是 **依赖推导**、**资源管理** 和 **执行优化** 的基石。以下是具体原因和背后的设计逻辑：

---

### **1. 依赖关系自动推导**
#### **(1) 构建有向无环图（DAG）**
RenderGraph 的核心是通过 Pass 对资源的读写声明，自动构建依赖关系图（DAG）。每个 Pass 的输入输出资源决定了其执行顺序：
- **若 Pass A 写入资源 X，Pass B 读取 X**：RenderGraph 会自动插入边 `A → B`，确保 A 在 B 之前执行。
- **若 Pass 未声明资源**：依赖关系无法推导，可能导致执行顺序错误（如 B 在 A 之前执行，读取未更新的数据）。

#### **(2) 避免隐式依赖**
传统渲染流程中，Pass 可能通过全局变量或隐式约定访问资源（如直接使用 `g_ShadowMap`），这种隐式依赖会导致：
- **代码脆弱性**：修改一个 Pass 的资源使用可能破坏其他 Pass，且难以追踪。
- **无法自动化**：RenderGraph 无法通过静态分析发现所有隐式依赖。

**示例**：若阴影 Pass 未声明写入 `ShadowMap`，而光照 Pass 直接读取它，RenderGraph 无法确保阴影 Pass 先执行，导致光照 Pass 使用无效数据。

---

### **2. 资源生命周期管理**
#### **(1) 按需分配与复用**
RenderGraph 根据资源声明推导其生命周期：
- **创建时机**：资源在首次被写入的 Pass 执行前分配。
- **销毁时机**：资源在最后一个读取它的 Pass 完成后回收。
- **复用优化**：不同 Pass 的临时资源若生命周期不重叠，可复用同一块内存（Aliasing）。

**若 Pass 使用未声明资源**：
- RenderGraph 无法追踪该资源的生命周期，可能导致：
  - **内存泄漏**：资源未被正确释放。
  - **访问违规**：资源未分配时被使用（如未声明的中间纹理）。

#### **(2) 显式资源边界**
- **逻辑资源 vs 物理资源**：  
  RenderGraph 允许资源通过别名（Aliasing）复用内存（如临时纹理 `TempBuffer1` 和 `TempBuffer2` 可指向同一物理内存），但需明确声明它们的读写范围。
- **未声明资源的风险**：  
  若 Pass 隐式使用资源，可能导致别名策略失效（如两个 Pass 误用同一物理内存）。

---

### **3. 执行优化与同步**
#### **(1) 资源屏障（Barrier）自动化**
GPU 需要资源状态同步（如纹理从 `WRITE` 切换为 `READ`）。RenderGraph 根据资源声明自动插入屏障：
- **若 Pass A 写入资源 X，Pass B 读取 X**：RenderGraph 自动插入 `X` 的 `WRITE → READ` 屏障。
- **未声明资源**：屏障缺失，导致 GPU 状态错误（如读取未完成写入的数据）。

#### **(2) 并行执行优化**
RenderGraph 可将无依赖关系的 Pass 并行提交到不同 GPU 队列（如同时执行 Compute 和 Graphics Pass）：
- **依赖不完整**：若 Pass 未声明资源，可能错误并行执行冲突操作（如同时写入同一资源）。

**示例**：  
两个 Compute Pass 均写入 `GlobalBuffer`，若未声明，RenderGraph 可能允许它们并行执行，导致数据竞争。

---

### **4. 安全性与可维护性**
#### **(1) 契约式设计**
- **显式接口**：Pass 通过声明资源，明确其输入输出接口，类似函数参数定义。
- **降低耦合**：Pass 仅依赖声明的资源名称，而非具体实现，便于独立开发和替换。

#### **(2) 调试与验证**
- **静态检查**：在 Setup 阶段即可验证资源是否存在、格式是否匹配（如要求 `GBuffer.Normal` 必须是 `RGBA16F` 格式）。
- **未声明资源的后果**：错误仅在运行时暴露（如崩溃或渲染错误），难以调试。

**示例**：  
若后处理 Pass 误用了未声明的 `HDRBuffer`（实际应为 `LDRBuffer`），RenderGraph 在 Setup 阶段即可报错，而非在运行时出现颜色异常。

---

### **5. 设计哲学：数据驱动与确定性**
#### **(1) 数据驱动架构**
RenderGraph 将渲染流程抽象为数据（图结构），而非硬编码逻辑：
- **声明即数据**：Pass 和资源声明构成渲染流程的“元数据”，可用于序列化、动态调整（如通过配置文件切换抗锯齿算法）。
- **未声明资源的破坏性**：隐式操作会破坏数据的完整性和可预测性。

#### **(2) 确定性执行**
- **可重复性**：相同的声明总是生成相同的执行流程，便于测试和重现问题。
- **未声明资源的风险**：隐式依赖可能导致执行顺序随代码变动而不可控。

---

### **实际案例：Unreal Engine RDG 的严格声明**
在 Unreal Engine 的 **Render Dependency Graph (RDG)** 中：
- **强制声明**：每个 Pass 必须通过 `RDG_READ_TEXTURE` 或 `RDG_WRITE_TEXTURE` 宏声明资源。
- **编译时检查**：未声明的资源访问会触发编译错误。
- **优化结果**：RDG 通过严格声明实现了多线程提交和显存复用，在《堡垒之夜》中减少了 30% 的显存占用。

---

### **总结**
强制 Pass 声明读写资源是 RenderGraph 实现 **自动化、优化与安全** 的核心机制。它通过以下方式解决了传统渲染流程的痛点：
1. **依赖透明化**：构建精确的 DAG，避免执行顺序错误。
2. **资源可控化**：按需分配、复用和回收，减少内存浪费。
3. **执行最优化**：自动插入屏障、并行调度，提升 GPU 利用率。
4. **开发安全化**：静态检查、接口明确，降低维护成本。

这种设计以显式声明为代价，换取了渲染流程的可靠性、可扩展性和跨平台适配能力，尤其适合现代复杂渲染管线。

## Question 4

RenderGraph的Compile 阶段和Execute 阶段到底进行了哪些操作，能不能介绍下？

## Answer 4

RenderGraph 的 **Compile（编译）阶段** 和 **Execute（执行）阶段** 是继 Setup（声明）阶段后的关键流程，它们将声明的渲染流程转化为实际的 GPU 操作。以下是这两个阶段的核心操作和设计逻辑：

---

### **1. Compile 阶段：从声明到可执行计划**
Compile 阶段负责将 Setup 阶段声明的 Pass 和资源转换为可执行的渲染流程，核心操作包括：

#### **(1) 依赖分析与图排序**
- **构建有向无环图（DAG）**  
  通过 Pass 的读写声明，自动生成依赖关系图。例如：  
  - Pass A 写入资源 X → Pass B 读取 X → 边 A→B 被创建。  
  - Pass C 和 D 无共享资源 → 可并行执行。
- **拓扑排序**  
  将 DAG 转换为线性执行顺序，确保依赖顺序正确。例如：`阴影 Pass → G-Buffer Pass → 光照 Pass → 后处理 Pass`。

#### **(2) 资源生命周期推导**
- **生存期计算**  
  确定每个资源的创建和销毁时机：  
  - **首次使用**：在第一个写入或读取它的 Pass 之前创建。  
  - **最后使用**：在最后一个读取它的 Pass 之后销毁。
- **内存复用（Aliasing）**  
  若两个资源的生存期不重叠且格式兼容，复用同一块物理内存。例如：  
  - Bloom 的中间纹理 `BloomTemp1` 和 `BloomTemp2` 可共享内存。

#### **(3) 资源分配策略**
- **按需分配**  
  仅在资源首次被使用时分配内存，而非在声明时立即分配。例如：  
  - 若某中间纹理仅在特定条件下使用（如开启 SSAO），则在不满足条件时不会被分配。
- **跨平台适配**  
  根据目标 GPU 调整资源格式和内存布局。例如：  
  - 移动端使用 `ASTC` 纹理格式，PC 端使用 `BC7`。

#### **(4) 同步优化**
- **自动插入资源屏障**  
  分析 Pass 之间的资源状态转换（如 `WRITE → READ`），插入必要的 GPU 屏障（如 `VkImageMemoryBarrier`）。  
  - 示例：阴影 Pass 写入 `ShadowMap` 后，光照 Pass 读取前，自动插入 `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` 转换。
- **屏障合并**  
  减少冗余屏障，例如将多个相邻的 `Texture → RenderTarget` 转换合并为一次操作。

#### **(5) Pass 优化**
- **Pass 合并**  
  合并无依赖关系的 Pass 以减少 Draw Call 开销。例如：  
  - 多个全屏后处理 Pass（如 Bloom 和 Tonemapping）合并为单个 Compute Pass。
- **队列分配**  
  将 Pass 分配到不同 GPU 队列（如 Graphics、Compute、Transfer）以实现异步执行。例如：  
  - 将天空盒渲染（Graphics）与光照计算（Compute）并行提交。

---

### **2. Execute 阶段：执行优化后的渲染计划**
Execute 阶段将 Compile 阶段的计划转化为实际的 GPU 指令，核心操作包括：

#### **(1) 资源物理分配**
- **延迟分配（Lazy Allocation）**  
  在 Pass 即将执行前分配资源内存，确保最小化显存占用。例如：  
  - G-Buffer 的纹理在第一个 Geometry Pass 执行前才分配。
- **别名内存绑定**  
  将逻辑资源映射到复用的物理内存。例如：  
  - `PostProcessTemp1` 和 `PostProcessTemp2` 交替使用同一块内存。

#### **(2) Pass 执行调度**
- **按拓扑顺序执行**  
  严格按 Compile 阶段生成的顺序提交 Pass。例如：  
  1. Shadow Pass → 2. G-Buffer Pass → 3. Lighting Pass → 4. PostProcess Pass。
- **多线程提交**  
  利用多线程生成 Command Buffer，例如：  
  - 主线程处理 Graphics Pass，子线程处理 Compute Pass。

#### **(3) 资源状态管理**
- **动态状态转换**  
  在 Pass 执行前后自动切换资源状态。例如：  
  - 执行阴影 Pass 前，将 `ShadowMap` 切换为 `D3D12_RESOURCE_STATE_DEPTH_WRITE`。  
  - 执行光照 Pass 前，将其切换为 `D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE`。
- **临时资源回收**  
  在资源生存期结束后立即回收内存。例如：  
  - 后处理链的中间纹理在最后一帧使用后立即释放。

#### **(4) GPU 指令提交**
- **Command Buffer 录制**  
  将 Pass 逻辑转化为 GPU 指令（如 `vkCmdDrawIndexed`、`ID3D12GraphicsCommandList::DrawInstanced`）。  
  - 示例：光照 Pass 录制 Command Buffer 包括设置 PipelineState、绑定 DescriptorHeap、提交 Draw Call。
- **异步执行**  
  将不同队列的 Command Buffer 并行提交到 GPU。例如：  
  - Compute 队列处理粒子模拟，Graphics 队列处理几何渲染。

---

### **3. Compile 与 Execute 的协作示例**
以 **Bloom 后处理链** 的实现为例：
1. **Setup 阶段**：声明 Bloom 所需的 `BrightPassTexture`、`DownsampleTextures[4]`、`UpsampleTextures[3]`。
2. **Compile 阶段**：  
   - 推导 Bloom 各 Pass 的依赖关系（如 `Downsample → Upsample`）。  
   - 复用 `DownsampleTextures` 和 `UpsampleTextures` 的内存（生存期不重叠）。  
   - 合并相邻的 Downsample Pass 到同一 Command Buffer。
3. **Execute 阶段**：  
   - 按顺序执行 Downsample → Upsample Pass。  
   - 动态分配/复用中间纹理内存。  
   - 自动插入 `Texture → RenderTarget` 和 `RenderTarget → Texture` 的屏障。

---

### **4. 与传统流程的对比**
| **阶段**       | **传统流程**                              | **RenderGraph**                              |
|----------------|------------------------------------------|---------------------------------------------|
| **资源分配**   | 硬编码在 Pass 中，可能导致过度预分配。     | 按需分配，支持内存复用（Aliasing）。          |
| **Pass 顺序**  | 代码顺序决定执行顺序，难以优化。           | 依赖推导 + 拓扑排序，支持动态重排。           |
| **同步管理**   | 手动插入屏障，易出错或冗余。               | 自动分析并优化屏障插入。                      |
| **扩展性**     | 修改需重构代码。                           | 动态增删 Pass（如通过配置文件）。             |

---

### **5. 实际引擎中的应用**
- **Unreal Engine RDG**：  
  - **Compile 阶段**：通过 `RDG_EVENT` 和 `RDG_GPU_STAT` 统计资源使用，优化 Pass 合并。  
  - **Execute 阶段**：利用 RHI 多线程提交 Command List，异步执行 Compute Shader。
- **Frostbite Frame Graph**：  
  - **Compile 阶段**：支持动态插入降分辨率 Pass 以适配性能需求。  
  - **Execute 阶段**：跨帧资源复用（如上一帧的 Motion Vector 用于 TAA）。

---

### **总结**
- **Compile 阶段** 是 RenderGraph 的“大脑”：  
  通过全局分析，将声明转化为优化的执行计划，解决资源分配、依赖管理和同步问题。
- **Execute 阶段** 是 RenderGraph 的“双手”：  
  严格按计划执行，确保 GPU 指令高效、正确提交，同时管理资源生命周期。

这种分离设计使 RenderGraph 能够实现 **声明式渲染**、**自动化优化** 和 **跨平台一致性**，尤其适合复杂、动态的现代渲染管线（如开放世界游戏、实时光线追踪）。