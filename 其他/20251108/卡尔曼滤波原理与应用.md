# 卡尔曼滤波原理与应用

### 🧑‍💻 User

什么是卡尔曼滤波算法（Kalman Filter）？

---

### 🤖 Assistant

**卡尔曼滤波（Kalman Filter）** 是一种高效的**递归滤波算法**，用于从一系列包含噪声的测量数据中估计动态系统的状态。

简单来说，它的核心思想是：**“既不完全相信理论模型的预测，也不完全相信传感器的测量，而是将两者结合起来，根据各自的可靠程度（不确定性），计算出一个最接近真实值的估计。”**

它是现代控制理论和信号处理中最著名的算法之一，广泛应用于导航（GPS）、机器人、自动驾驶、航空航天（如阿波罗登月）和金融领域。

---

### 1. 核心直觉：为什么要用卡尔曼滤波？

假设你开发了一个跟踪小车的机器人：

1.  **理论推算（预测）：** 你知道小车上一秒的位置和速度，根据物理公式，你可以算出它“应该”在哪。但是，路面可能打滑，风阻可能变化，所以这个推算有误差（**过程噪声**）。
2.  **传感器测量（观测）：** 小车上装了 GPS。GPS 会告诉你小车在哪。但是，GPS 信号有干扰，精度有限，所以这个读数也有误差（**测量噪声**）。

**卡尔曼滤波做的事情就是：**
它通过计算**不确定性（协方差）**，来决定在这个时刻，是更相信“理论推算”，还是更相信“GPS测量”。
*   如果 GPS 很准，卡尔曼增益（Kalman Gain）就会变大，权重偏向测量值。
*   如果车子运动很平稳（理论模型很准）而 GPS 信号不好，权重就会偏向理论推算。

---

### 2. 数学原理

卡尔曼滤波假设系统是**线性**的，且噪声符合**高斯分布（正态分布）**。

#### 2.1 状态空间模型
我们需要定义两个方程来描述系统：

1.  **状态预测方程（物理模型）：**
    $$x_k = F x_{k-1} + B u_{k-1} + w_{k-1}$$
    *   $x_k$: 当前时刻的状态向量（如：位置、速度）。
    *   $F$: 状态转移矩阵（如何从上一状态推导当前状态）。
    *   $u_{k-1}$: 控制输入（如：踩了多少油门）。
    *   $B$: 控制输入矩阵。
    *   $w_{k-1}$: 过程噪声（Process Noise），服从高斯分布 $N(0, Q)$。

2.  **测量方程（传感器模型）：**
    $$z_k = H x_k + v_k$$
    *   $z_k$: 测量值（传感器读数）。
    *   $H$: 测量矩阵（将状态映射到测量值，例如状态是[位置, 速度]，测量只有[位置]，则 $H$ 负责提取位置）。
    *   $v_k$: 测量噪声（Measurement Noise），服从高斯分布 $N(0, R)$。

---

### 3. 算法流程：两个步骤的循环

卡尔曼滤波是一个无限循环的过程，分为 **“预测（Predict）”** 和 **“更新（Update）”** 两个阶段。

#### 第一阶段：预测 (Time Update)
根据上一时刻的最佳估计，通过物理模型“猜”当前时刻的状态。

1.  **预测状态：**
    $$\hat{x}_k^- = F \hat{x}_{k-1} + B u_{k-1}$$
    *(注：$\hat{x}^-$ 表示先验估计，即还没看传感器数据之前的估计)*

2.  **预测误差协方差（不确定性）：**
    $$P_k^- = F P_{k-1} F^T + Q$$
    *   $P$: 协方差矩阵，代表我们要么确信现在的估计。
    *   $Q$: 过程噪声协方差。随着时间推移，如果不观测，不确定性会变大。

#### 第二阶段：更新 / 修正 (Measurement Update)
拿到传感器的测量值 $z_k$，修正刚才的预测。

1.  **计算卡尔曼增益 (Kalman Gain, $K$)：**
    $$K_k = P_k^- H^T (H P_k^- H^T + R)^{-1}$$
    *   这是算法的灵魂。
    *   如果测量噪声 $R$ 很小，$K$ 接近 1 $\rightarrow$ 相信测量。
    *   如果预测误差 $P$ 很小，$K$ 接近 0 $\rightarrow$ 相信预测。

2.  **更新状态估计 (得到最优解)：**
    $$\hat{x}_k = \hat{x}_k^- + K_k (z_k - H \hat{x}_k^-)$$
    *   $z_k - H \hat{x}_k^-$ 称为**残差（Innovation）**，即测量值与预测值的差。
    *   最终结果 = 预测值 + 增益 $\times$ 残差。

3.  **更新误差协方差：**
    $$P_k = (I - K_k H) P_k^-$$
    *   由于引入了观测数据，不确定性 $P$ 通常会减小。

---

### 4. Python 代码示例 (一维卡尔曼滤波)

假设我们在测量一个房间的恒定温度，但温度计很吵（噪声大）。

```python
import numpy as np
import matplotlib.pyplot as plt

# 1. 模拟数据生成
np.random.seed(42)
true_temp = 25.0  # 真实温度
n_iter = 50       # 迭代次数

# 生成测量数据：真实值 + 高斯噪声
measurement_noise = 2.0  # 测量标准差
z = np.random.normal(true_temp, measurement_noise, n_iter)

# 2. 卡尔曼滤波初始化
# 状态估计值 (初始猜测)
x_est = 0.0 
# 估计误差协方差 (初始不确定性，设大一点表示完全不确定)
P = 100.0 

# 系统参数
Q = 1e-5     # 过程噪声协方差 (假设真实温度基本不变，所以很小)
R = measurement_noise**2 # 测量噪声协方差 (传感器的方差)

# 记录结果用于绘图
x_est_history = []
P_history = []

# 3. 卡尔曼滤波循环
for k in range(n_iter):
    # --- 预测 (Predict) ---
    # 状态预测: 认为温度不变 x_k = x_{k-1}
    x_pred = x_est
    # 协方差预测: P_k = P_{k-1} + Q
    P_pred = P + Q
  
    # --- 更新 (Update) ---
    # 计算卡尔曼增益: K = P / (P + R)
    K = P_pred / (P_pred + R)
  
    # 更新状态: x = x_pred + K * (z - x_pred)
    x_est = x_pred + K * (z[k] - x_pred)
  
    # 更新协方差: P = (1 - K) * P_pred
    P = (1 - K) * P_pred
  
    # 保存数据
    x_est_history.append(x_est)
    P_history.append(P)

# 4. 打印最后几次结果
print(f"真实温度: {true_temp}")
print(f"最后一次测量值: {z[-1]:.4f}")
print(f"卡尔曼估计值: {x_est:.4f}")
```

### 5. 优缺点总结

**优点：**
*   **数据融合：** 能完美结合多传感器数据和物理模型。
*   **递归特性：** 不需要保存历史数据，只需要保存上一个状态，非常适合实时系统（Real-time systems）。
*   **平滑去噪：** 能有效过滤高斯噪声。

**缺点：**
*   **线性假设：** 标准 KF 只能处理线性系统。如果是复杂非线性系统（如机器人剧烈转向），需要使用 **扩展卡尔曼滤波 (EKF)** 或 **无迹卡尔曼滤波 (UKF)**。
*   **高斯假设：** 假设噪声符合正态分布，如果噪声是重尾分布或其他奇怪分布，效果会变差（此时可能需要粒子滤波 Particle Filter）。

### 6. 常见应用场景
*   **导航系统：** 手机 GPS 在静止时坐标会乱跳，卡尔曼滤波将其平滑，使其显示在地图上的一个点。
*   **自动驾驶：** 融合激光雷达 (Lidar)、雷达 (Radar) 和摄像头的数据，判断周围车辆的位置和速度。
*   **无人机飞控：** 通过加速度计和陀螺仪的数据融合，计算无人机的姿态（Roll, Pitch, Yaw）。
*   **股市预测：** 尽管很难，但有人用它来平滑股价波动以寻找趋势。