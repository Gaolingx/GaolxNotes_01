# 深度优先与广度优先区别

### 🧑‍💻 User

深度优先搜索和广度优先搜索有什么区别？

---

### 🤖 Assistant

深度优先搜索 (**DFS**, Depth-First Search) 和广度优先搜索 (**BFS**, Breadth-First Search) 是图论和树遍历中最基础、最重要的两种算法。

它们的核心区别在于**搜索的顺序**和**使用的数据结构**。简单来说：**DFS 是“不撞南墙不回头”，BFS 是“层层推进”。**

以下是两者的详细对比：

### 1. 核心逻辑对比

| 特性 | 深度优先搜索 (DFS) | 广度优先搜索 (BFS) |
| :--- | :--- | :--- |
| **直观理解** | **纵向挖掘**。选择一条路一直走到底，直到无路可走再回退（回溯）。 | **横向扫描**。先访问离起点最近的所有节点，像水波纹一样一层层向外扩展。 |
| **核心数据结构** | **栈 (`Stack`)**。通常通过**递归**隐式实现，或者手动维护一个显式的栈。 | **队列 (`Queue`)**。通常使用双端队列（如 Python 的 `deque`）实现。 |
| **最短路径** | **不能保证**找到最短路径。它可能绕了很大的圈子才找到目标。 | **一定能**找到**无权图**中的最短路径（从起点到终点的最少边数）。 |
| **空间复杂度** | 一般较低。与树/图的**深度**相关。 | 一般较高。与树/图的**宽度**（最大层节点数）相关。 |

---

### 2. 算法图解原理

假设我们在遍历一棵二叉树：

*   **DFS (深度优先):**
    1.  从根节点出发，立刻访问左子节点。
    2.  如果左子节点还有左子节点，继续向下，直到到达叶子节点（最深处）。
    3.  **回溯**到上一个节点，去访问右子节点。
    4.  重复此过程。
    *   *口诀：一条道走到黑，不行再退回来。*

*   **BFS (广度优先):**
    1.  把根节点放入队列。
    2.  拿出根节点，将其所有的**直接**子节点（第一层）放入队列。
    3.  依次拿出第一层的节点，将它们的子节点（第二层）放入队列。
    4.  按顺序处理，直到队列为空。
    *   *口诀：一层一层剥洋葱。*

---

### 3. 时间与空间复杂度分析

假设图中有 $V$ 个顶点 (Vertices) 和 $E$ 条边 (Edges)。

*   **时间复杂度:**
    两者通常都是 $O(V + E)$。因为在最坏情况下，每个节点和每条边都会被访问一次。

*   **空间复杂度:**
    *   **DFS:** $O(h)$，其中 $h$ 是树或图的最大深度。在最坏情况（单链表形状）下是 $O(V)$。DFS 节省内存，因为它只需要记录当前路径上的节点。
    *   **BFS:** $O(w)$，其中 $w$ 是树或图的最大宽度（也就是某一层最多的节点数）。在最坏情况下（例如星型图的中心到周围），队列可能需要存储 $O(V)$ 个节点。**通常 BFS 比 DFS 占用更多内存。**

---

<details>
<summary><strong>👇 点击展开：代码实现对比 (Python)</strong></summary>

这里使用 Python 演示在一个简单的图结构中两者的区别。

图的结构 (邻接表):
```python
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
```

#### 1. DFS 实现 (递归版)

DFS 代码非常简洁，利用系统的调用栈。

```python
def dfs(graph, node, visited):
    if node not in visited:
        print(node, end=" ")  # 处理当前节点
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

# 调用
print("DFS Path:")
dfs(graph, 'A', set())
# 输出可能是: A B D E F C (取决于邻居的遍历顺序)
```

#### 2. BFS 实现 (队列版)

BFS 必须使用队列来实现先进先出 (FIFO)。

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft() # 从左边弹出（队头）
        print(vertex, end=" ")   # 处理当前节点

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor) # 加到右边（队尾）

# 调用
print("\nBFS Path:")
bfs(graph, 'A')
# 输出: A B C D E F (按层级访问)
```

</details>

<details>
<summary><strong>👇 点击展开：典型应用场景</strong></summary>

根据两者的特性，它们适用的场景截然不同：

#### 适合使用 BFS (广度优先) 的场景：
1.  **无权图的最短路径:** 寻找迷宫中起点到终点的最少步数、社交网络中的“六度人脉”（查找两个人的最近关系）。
2.  **层级遍历:** 需要按层打印二叉树。
3.  **连通性检查:** 垃圾回收机制（Garbage Collection）中的 Cheney 算法。
4.  **P2P 网络:** 寻找最近的邻居节点。

#### 适合使用 DFS (深度优先) 的场景：
1.  **全排列/组合问题:** 比如解决数独、八皇后问题。
2.  **路径存在性判断:** 只需要知道“能不能从A到B”，不在乎路径长短。
3.  **拓扑排序:** 解决任务依赖关系（如编译顺序）。
4.  **检测环:** 判断图中是否存在环。
5.  **图的连通分量:** 寻找图中孤立的岛屿。

</details>

### 总结

*   如果你需要找**最短路径**或者目标离起点**较近**，优先选 **BFS**。
*   如果你需要**穷尽所有可能**、做**回溯**算法，或者图的**深度非常深**但你只需要找任意一个解，优先选 **DFS**。