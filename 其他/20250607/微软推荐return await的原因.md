# 微软推荐return await的原因

### 🧑‍💻 User

我记的微软的官方指导里比起直接return一个task，更推荐return await，这是为什么？

---

### 🤖 Assistant

微软官方确实推荐在异步方法中优先使用 `return await` 而不是直接 `return task`，主要原因在于 **异常处理、执行上下文流动和堆栈跟踪清晰度** 这三方面的关键差异：

1.  **异常处理行为（最核心原因）**:
    *   **直接 `return task`**: 如果 `task` 代表的异步操作在**开始执行之前**就发生了异常（例如，参数验证失败、资源获取失败等同步异常），或者该 `task` 本身是由一个 `async` 方法调用产生的，但该调用**尚未被 `await`** 就返回了，那么这个异常会**直接同步抛出**给当前方法的调用者。这违背了异步方法的常规预期（即所有错误都应通过返回的 `Task` 对象传播）。
    *   **`return await task`**: 使用 `await` 会**捕获**在等待 `task` 完成过程中发生的**所有异常**（无论是同步异常还是异步异常），并将它们**存储**在由 `return await` 语句最终返回的那个新 `Task` 中。调用者总是通过检查或等待这个返回的 `Task` 来获取异常，行为完全符合异步方法的契约。这确保了异常的一致性和可预测性。

2.  **执行上下文的流动**:
    *   **直接 `return task`**: 执行上下文（`ExecutionContext`，包含如安全上下文、文化设置、逻辑调用上下文等）**不会**自动跟随返回的 `task` 流动到该任务后续的延续（continuation）中。如果该 `task` 的后续操作依赖于原始执行上下文（在 ASP.NET Core 等环境中非常常见），这可能导致问题（如 `HttpContext` 丢失、文化信息错误等）。
    *   **`return await task`**: `await` 关键字的一个重要职责就是**捕获并恢复执行上下文**。当你在 `async` 方法中使用 `await task` 时：
        1.  当前执行上下文被捕获。
        2.  方法可能挂起（如果 `task` 未完成）。
        3.  当 `task` 完成并调度延续时，之前捕获的执行上下文会**被恢复**用于执行 `await` 之后的代码（包括 `return`）。
        这意味着通过 `return await task` 最终返回给调用者的 `Task`，其后续操作（如等待它或附加延续）会正确地在其原始的或预期的执行上下文中运行。这对于依赖上下文的框架（如 ASP.NET Core）至关重要。

3.  **堆栈跟踪清晰度**:
    *   **直接 `return task`**: 如果返回的 `task` 最终出错，异常的堆栈跟踪**可能丢失原始抛出点**到返回点之间的调用栈信息。调试时，你可能只看到异常在最终被等待的地方抛出，或者在一个底层任务调度上下文中抛出，难以追溯到最初导致错误的实际代码位置。
    *   **`return await task`**: 因为 `await` 机制在异步状态机中处理异常，当异常最终通过返回的 `Task` 传播出去时，堆栈跟踪通常会包含**更完整的信息**，清晰地展示从原始异常抛出点，经过 `await` 点，一直到 `return await` 语句的路径。这大大简化了调试过程。

**总结推荐 `return await` 的原因：**

| **方面**         | **`return task`**                     | **`return await task`**                | **推荐原因**                                     |
| :--------------- | :------------------------------------ | :------------------------------------- | :--------------------------------------------- |
| **异常处理**     | 同步异常直接抛出                      | **所有异常封装进 Task**                | **一致、安全的异步错误处理**                   |
| **执行上下文**   | 上下文可能丢失                        | **上下文自动流动**                     | **在 ASP.NET Core 等环境中保持上下文至关重要** |
| **堆栈跟踪**     | 调用栈可能不完整                     | **提供更清晰的错误溯源**               | **显著简化调试过程**                           |
| **行为一致性**   | 违背异步方法契约                     | **完全符合异步方法预期**               | **代码行为更可预测**                           |

**重要说明：**

1.  **性能考量**: 使用 `return await` 会引入一个额外的异步状态机层（因为 `await` 需要编译器生成状态机代码），理论上比直接 `return task` 有极小的开销。**然而，在绝大多数应用场景中，这个开销是微不足道的，并且被上述优点（尤其是正确性和可维护性）远远超越。** 微软的指导明确优先考虑正确性。**除非**你是在一个性能极其敏感的热路径（hot path）上，并且**完全理解**直接 `return task` 不会引起上述问题（例如，返回一个已经完成的、不可能有同步异常的缓存 `Task` 实例，如 `Task.CompletedTask`），否则应遵循推荐使用 `return await`。
2.  **`Task<T>` vs `Task`**: 上述原则对 `Task<T>` 和 `Task`（无返回值）同样适用。
3.  **编译器警告**: 现代 C# 编译器（如 Roslyn）在某些可能引起混淆或潜在问题的场景下（例如在 `try` 块中直接 `return task`），会对直接 `return task` 发出警告 **CS1998 (This async method lacks 'await' operators and will run synchronously)**，提示你可能需要 `await`。遵循 `return await` 的推荐可以避免这类警告。

**结论：**

微软推荐 `return await task` 而非 `return task` 的核心驱动力是**确保异步方法在异常处理和执行上下文流动方面行为的一致性和正确性**，同时提供更好的调试体验。虽然存在微小的性能开销，但在绝大多数情况下，**正确性和可维护性的收益远大于这点开销**。因此，在编写 `async` 方法时，应该优先采用 `return await` 的写法，除非你有非常明确且合理的性能优化需求，并且完全确信直接 `return task` 是安全的。