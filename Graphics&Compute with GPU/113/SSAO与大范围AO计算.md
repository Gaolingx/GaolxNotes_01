# SSAO与大范围AO计算

### 🧑‍💻 User

为什么ssao非常难以计算大范围的ao，这通常需要一些依赖raytracing的gi才能实现。

---

### 🤖 Assistant

SSAO（Screen Space Ambient Occlusion，屏幕空间环境光遮蔽）之所以难以计算大范围（Large-scale）的 AO，本质上是由**屏幕空间算法的先天局限性**和**GPU 硬件架构的特性**共同决定的。

简单来说，SSAO 是一个基于“猜测”的近似算法，而想要获得大范围的遮蔽关系，这种猜测的代价会呈指数级上升，且准确度会急剧下降。

以下是具体的技术原因分析：

### 1. 数据的缺失（Screen Space Limitation）

SSAO 仅依赖于当前帧的 **G-Buffer**（主要是 Depth Buffer 和 Normal Buffer）。这意味着它是一个“管中窥豹”的算法。

*   **屏幕外几何体缺失**：如果造成遮蔽的物体在屏幕之外（Frustum 之外），或者被前景物体挡住（Z-Buffer 中没有该物体的数据），SSAO 根本无法知道它的存在。
*   **大范围意味着更多缺失**：当你计算局部 AO（比如衣服的褶皱）时，所需的数据通常都在相邻像素里。但当你试图计算大范围 AO（比如建筑物投射在地面上的阴影，或者房间角落的阴影）时，遮蔽物很可能位于屏幕边缘甚至屏幕外。如果不使用 Ray Tracing 或 Voxel，SSAO 对此无能为力。

### 2. 采样半径与缓存命中率（Sampling Radius & Cache Locality）

SSAO 的核心逻辑是在当前像素周围的一个球体（半球）内进行采样，对比深度值。

$$
A(p) = \frac{1}{\pi} \int_{\Omega} V(p, \omega) (n \cdot \omega) d\omega
$$

其中 $V$ 是可见性函数。在代码实现中，这是一个蒙特卡洛积分，需要循环采样 $N$ 次。

*   **小范围（Local）**：采样点都在当前像素附近。GPU 的纹理缓存（Texture Cache/L1/L2）非常喜欢这种访问模式，因为相邻像素的数据很可能已经被读入缓存了。
*   **大范围（Large-scale）**：为了捕捉大范围遮蔽，采样半径必须设得很大（例如跨越屏幕几百个像素）。
    *   **Cache Thrashing（缓存颠簸）**：采样点分布极其稀疏且跨度大，导致纹理采样频繁发生 **Cache Miss**。GPU 必须不断从显存（VRAM）中读取数据，导致带宽成为瓶颈，性能急剧下降。
    *   **步进问题**：如果为了性能减少采样数但保持大半径，会导致严重的**欠采样（Undersampling）**，表现为明显的噪点或条纹。

### 3. 几何厚度的缺失（Lack of Thickness Information）

这是 SSAO 最经典的缺陷，在大范围计算时尤为致命。

Z-Buffer 只有“一面”墙，它没有厚度。SSAO 算法通常假设遮蔽物是无限厚的，或者是薄片。
*   当采样半径很小时，物体表面的局部凹凸可以被视为简单的几何结构，误差不明显。
*   当采样半径很大时，算法可能会采样到很远背景的物体。例如，一个前景的角色站在一面远处的墙前面。
    *   SSAO 会发现背景墙的深度大于角色的深度。
    *   如果不加特殊的处理（Range Check），算法会误以为背景墙被角色遮挡了，或者角色被背景墙遮挡了，从而产生**错误的黑色光晕（Halo Artifacts）**。
    *   为了消除这种伪影，必须引入严格的深度阈值截断，但这反而切断了真正的长距离遮蔽效果。

### 4. 视角依赖性（View Dependence）

大范围 AO 应该是环境的一种固有属性（低频光照信息），不应随相机移动而剧烈变化。
然而，SSAO 是基于视角的。当你转动镜头，屏幕边缘的大范围遮蔽信息会突然消失或出现（因为产生遮蔽的物体移出了屏幕）。这种**时域上的不稳定（Temporal Instability）**在大范围 AO 上表现得比局部 AO 更明显，给玩家一种“阴影在闪烁”的廉价感。

---

### 为什么 Ray Tracing (GI) 能解决这个问题？

依赖 Ray Tracing 的 GI（或 RTAO - Ray Traced Ambient Occlusion）在根本上解决了上述问题：

1.  **世界空间（World Space）**：RT 访问的是 **BVH（Bounding Volume Hierarchy）** 结构，包含整个场景的完整几何信息，无论物体是否在屏幕内。
2.  **任意距离**：光线追踪的射线（Ray）可以射出任意长度。检测 1 米外的遮蔽和 100 米外的遮蔽，在逻辑上是一样的，只是遍历 BVH 的成本不同，不存在屏幕空间的“步进”和“缓存局部性”噩梦。
3.  **准确的几何关系**：RT 精确知道物体之间的空间距离，不会出现 SSAO 那种“分不清是前景还是背景”导致的 Halo 伪影。

### 总结

SSAO 的设计初衷就是为了以极低的消耗模拟**高频的、局部的**接触阴影（Contact Shadows）。

试图用 SSAO 做大范围 AO，就像试图用放大镜去观察整个城市：
1.  你看不全（屏幕边缘切断）。
2.  你移动太慢（Cache Miss 导致性能低下）。
3.  你失去了透视关系（无法处理厚度和分离的物体）。

因此，现代引擎通常采用混合方案：用 **SSAO/GTAO** 处理微小的褶皱和接触阴影，用 **SDF AO（距离场 AO）、Voxel AO（体素 AO）** 或 **Ray Tracing** 来处理大范围的环境遮蔽。

---

### 🧑‍💻 User

有没有一种可能 当rtgi的精度足够高的时候，用gi也可以实现ao的很多效果了？

---

### 🤖 Assistant

这不仅仅是“可能”，在物理原理和高端渲染的发展趋势上，**这绝对是事实**。

实际上，**Ambient Occlusion (AO) 本质上就是全局光照 (GI) 的一种廉价的、简化的近似**。

当你的 RTGI（光线追踪全局光照）精度达到“无限高”（即全路径追踪 Path Tracing）时，AO 这个概念就不再作为一种独立的技术存在了，它会自然地融入到光照计算中。

以下是详细的分析：

### 1. 物理本质：AO 是 GI 的子集

让我们看渲染方程（Rendering Equation）：

$$
L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) (n \cdot \omega_i) d\omega_i
$$

*   **GI (Global Illumination)**：试图求解这个积分的完整值。它计算从四面八方射入的光线 $L_i$，这些光线有的来自天空（天光），有的来自其他物体反射（间接光）。
*   **AO (Ambient Occlusion)**：为了简化计算，假设场景被一个**均匀的白色光**包围（即 $L_i$ 是常数）。那么积分就变成只计算“有多少光线被挡住了”。

**结论**：如果 GI 能够极其精确地计算出每一束进入角落的光线，那么角落自然会变黑（因为反射光进不去）。这时候，你计算出的图像天然就包含了 AO 的效果。

在离线渲染（如影视特效、皮克斯动画）中，**“AO Pass”往往不再用于直接合成最终画面**，因为路径追踪渲染器算出来的图已经包含了完美的遮蔽效果。AO 通道现在更多是留给合成师（Compositor）用来在后期微调画面对比度或做风格化处理的。

### 2. 为什么在实时渲染中，即便有 RTGI，我们有时还是需要 AO？

虽然理论上 RTGI 包含了 AO，但在目前的硬件水平下（即使是 RTX 4090），单纯依靠 RTGI 来替代所有 AO 效果还存在两个主要瓶颈：

#### A. 频率与分辨率问题 (Frequency & Resolution)

*   **GI 通常是低频的**：为了性能，实时 RTGI（如 UE5 的 Lumen 或 NVIDIA 的 RTXGI）通常不会对每个像素射出几十条光线。它们往往在半分辨率、甚至更低的探针（Probe）网格上计算，或者严重依赖时域累积（Temporal Accumulation）。这意味着 RTGI 擅长处理**大范围的**光照反弹（比如红墙把地板映红）。
*   **AO 需要高频细节**：衣服的缝隙、砖块的纹理凹凸、螺丝钉周围的阴影，这些属于极高频的细节。如果用 RTGI 去算这些，你需要极高密度的光线才能击中那些微小的缝隙。
*   **现状**：目前的 RTGI 很容易把微小的接触阴影“涂抹”掉（Denoising 造成的模糊）。因此，我们仍然叠加一层 **SSAO** 或 **GTAO**，专门用来增强这些**微观几何（Micro-geometry）**的体积感。

#### B. 漏光与接触阴影 (Light Leaking & Contact Shadows)

由于实时 RTGI 经常使用简化的几何体（例如 Lumen 使用的 Mesh Distance Fields 或 Surface Cache），它可能无法精确匹配高模的表面。这会导致物体放在地面上时，底部没有完全变黑，产生“悬浮感”。
专门的 AO（特别是 Ray Traced AO 或 Screen Space Contact Shadows）可以强制压暗这些接触区域，让物体“落地”。

### 3. 未来的演变：从 AO 到 "Micro-Shadowing"

随着显卡算力的提升，我们正在经历一个术语和技术的转变：

1.  **大范围遮蔽 (Large Scale Occlusion)**：已经被 GI 接管。正如你所说，以前用 AO 模拟的“房间角落变黑”，现在完全由 RTGI 的间接光照衰减来自然实现。
2.  **小范围遮蔽 (Small Scale Occlusion)**：依然保留。但它越来越不像传统的 AO（均匀压暗），而更多地被称为 **Micro-Shadowing** 或 **Contact Hardening**。

**一个现代的高端渲染管线（如 Cyberpunk 2077 的 Overdrive 模式）可能是这样的：**

*   **不使用** 传统的 SSAO 去模拟大范围阴影（因为那是假的，而且不准）。
*   **使用** RTGI (Path Tracing) 计算所有的光照反弹和主要的遮蔽关系。
*   **可能保留** 一个极小半径的 GTAO 或者利用 Normal Map 导出的 Cavity Map，用来补充那些连光追都无法捕捉到的、纹理级别的微小缝隙阴影。

### 总结

**是的，当 RTGI 精度足够高（接近 Path Tracing）时，它不仅能实现 AO 的效果，而且比 AO 更真实。**

AO 模拟的是“环境光被遮挡”，而高精度 GI 计算的是“光真的进不去”。物理世界中没有“AO”这种力或能量，只有“光照”。AO 只是我们在算力不足的时代，为了模仿光照不足而发明的一种聪明的“作弊手段”。随着算力提升，这种作弊手段正在逐渐退出现代图形学的舞台中心。

---

### 🧑‍💻 User

但现实情况却是，通过rdc查看ssgi pass的indirectdiffusecolor，即便经过Temporal +Spatial denoise之后，结果依旧很模糊（低频gi），精度似乎并不足以作为全局 AO使用，这是为什么？

---

### 🤖 Assistant

你的观察非常敏锐，而且**完全切中了当前实时渲染（Real-Time Rendering）领域最大的痛点**。

你看到的现象——“GI 哪怕降噪后依然很糊，缺乏高频细节，无法替代 AO 的接触阴影”——是**实时随机光线追踪（Stochastic Ray Tracing）**目前面临的根本性物理和数学难题。

这并不是因为算法写得烂，而是由**采样率（Sample Count）**和**降噪器（Denoiser）**的机制决定的。以下是深度解析：

### 1. 极低的采样率（The Sample Count Problem）

在离线渲染（Arnold, V-Ray）中，计算一个像素的 GI 可能需要发射几百甚至上千条光线（SPP > 500）。
但在实时渲染（60FPS）中，留给 SSGI 或 RTGI 的预算通常只有 **0.5 到 1 SPP（每像素每帧 0.5 到 1 条光线）**，甚至是 1/4 分辨率。

*   **信噪比（SNR）极低**：仅仅依靠 1 条光线，你得到的不是一个“颜色”，而是一个充满了**方差（Variance）**的噪点。
*   **高频信息的丢失**：要通过仅仅 1 次采样就探测到“墙角那条 1 厘米宽的缝隙是黑的”，概率极低。就像你在黑暗中只用激光笔指一下，很难正好指中那个缝隙。

### 2. 降噪器的“涂抹”本质（The Denoiser's Dilemma）

因为输入充满了噪点（Noise），我们必须使用降噪器（Denoising）。目前的工业标准通常是 SVGF（Spatiotemporal Variance-Guided Filtering）及其变种。

降噪器的工作原理本质上是一个**低通滤波器（Low-pass Filter）**，它的副作用直接导致了你看到的“模糊”：

*   **空间复用（Spatial Reuse）导致模糊**：为了填补噪点，算法会借用周围像素的信息来“平均化”。
    *   **问题**：当你想保留锐利的接触阴影（AO 效果）时，这就是灾难。接触阴影是高频信号（从亮到暗的突变）。降噪器很难区分“噪点”和“微小的锐利阴影”，它往往会把接触阴影当成噪点一起抹平了。
*   **时间复用（Temporal Reuse）导致鬼影和迟滞**：为了增加样本量，算法会混合上一帧的结果（通常占 90% 甚至更多）。
    *   **问题**：这虽然让画面变平滑了，但也让阴影变得“肉肉的”。快速移动的物体，或者快速变化的光照，其遮蔽细节会被上一帧的历史数据“冲淡”。

### 3. 漫反射的低频特性 vs. 遮蔽的高频特性

这是一个物理信号层面的矛盾。

*   **Indirect Diffuse（间接漫反射）**：物理上确实是**低频**的。红地毯把红光映到白墙上，这个渐变是非常平滑的。因此，GI 算法和降噪器倾向于大范围模糊处理，这符合漫反射的物理直觉。
*   **Occlusion（遮蔽/AO）**：这是几何关系产生的，它往往是**高频**的。物体落地处的线条是非常锐利的。

**矛盾点**：当你计算 SSGI 时，你是在试图用一套适合“平滑光照”的算法（低采样+强降噪）去解算出“锐利遮蔽”的结果。这就像用一把刷墙的大刷子去画眉毛，结果自然是糊成一团。

### 4. 分辨率缩放（Downsampling）

为了性能，SSGI 或 RTGI 往往不是在全分辨率下计算的：
*   很多引擎在 **半分辨率（Half-Res）** 甚至 **四分之一分辨率** 下计算 GI。
*   然后再通过 Upscaling（双边上采样）拉回到全屏。
*   这个上采样过程会进一步丢失那仅仅几像素宽的 AO 细节。

### 结论：为什么我们还需要 AO Pass？

正因为你看到的 RDC 结果——GI 太糊了——所以现代 AAA 游戏管线中，**AO（特别是 GTAO 或 RTAO）并没有被完全淘汰，而是换了角色**。

我们现在的做法通常是 **"Composite Approach"（组合法）**：

1.  **Large Scale (Low Frequency)**: 交给 **SSGI / RTGI**。让它负责大范围的颜色反弹（Color Bleeding）和环境光衰减。即使糊一点也没关系，因为漫反射本来就该软一点。
2.  **Small Scale (High Frequency)**: 依然强行叠加一层 **AO (SSAO/GTAO/RTAO)**。
    *   这层 AO 的半径设得很小（只关注接触面）。
    *   这层 AO 不参与多次反弹，只作为 `Multiplicative Term`（乘法项）直接压暗 Diffuse 甚至 Specular。

**只有当未来的显卡能够支持每像素 4-8 SPP 且配合更先进的 AI 降噪（如 DLSS Ray Reconstruction 这种能“脑补”出高频细节的技术）时，独立的 AO Pass 才会真正彻底消失。**

目前阶段，GI 负责“色”，AO 负责“形”，两者仍然需要互补。