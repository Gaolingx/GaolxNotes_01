# 延迟渲染与前向渲染

### 🧑‍💻 User

多盏点光源情况下，为什么手机的延迟比前向性能好，延迟可以低分辨率再手机超分，那带宽感觉也不是大问题了？前向不能做低分辨率后手机超分嘛？

---

### 🤖 Assistant

这是一个**非常典型、也非常容易被“表面结论”误导的问题**。直觉上看：

> “既然移动端可以低分辨率渲染 + 超分，那么多点光这种前向渲染是不是也能靠降分辨率解决？”

现实中答案是：**可以做，但收益远小于延迟渲染，且在多点光场景下往往失效**。原因不在“算力”，而在**数据依赖、带宽形态和光照复杂度的缩放方式**。

下面分层解释。

---

## 一、先给结论（工程视角）

在 **多盏点光源** 场景下：

* **延迟渲染**

  * 低分辨率 GBuffer + 光照 pass + 手机端超分
  * 性能收益**线性接近分辨率缩放**
  * 多光源 cost ≈ `Lights × 屏幕像素`
  * 非常适合 tile/clustered lighting
* **前向渲染**

  * 即使低分辨率 + 超分
  * **多光源 cost 仍然随 lights 急剧上升**
  * 超分只能降低像素数，**不能降低“每个像素要算多少光”**

所以表现为：

> **延迟在多光下明显更“抗光源数量”**

---

## 二、为什么“低分辨率 + 超分”对前向帮助有限？

### 1. 前向渲染的真正瓶颈不是“像素数”

前向在多点光下的核心成本是：

```
Fragment cost ≈ Pixels × Lights × BRDF
```

即使你把分辨率砍成 1/4：

* Pixels ↓ 4×
* 但 **Lights 不变**
* 每个 fragment 仍然要 loop 多个点光源

尤其在移动端：

* 点光 = attenuation + specular
* 动态分支难
* 寄存器压力大
* ALU/寄存器 stall 明显

所以：

> **你只是把“慢 × 多光源”变成了“稍微没那么慢 × 多光源”**

---

### 2. 超分并不能“合并光照计算”

超分能做的事情是：

* 重建几何边缘
* 重建纹理细节
* 重建 shading 频率变化较低的信号

但**点光源带来的变化是高频、非线性、视角相关的**：

* 高光位置对法线极其敏感
* 多光叠加不是线性的
* shadow / specular 都是 non-band-limited 信号

结果是：

* 你必须在 **低分辨率时就完整算所有光**
* 超分只是在“拉大已经算完的结果”

这和 TAAU / FSR 在 **光照后处理** 本质上是一样的。

---

## 三、延迟渲染为什么天然吃得下“低分辨率 + 超分”？

### 1. 延迟把“光源复杂度”从几何阶段剥离了

延迟渲染结构是：

1. GBuffer（低分辨率）
2. Lighting pass（屏幕空间）
3. 超分

关键点：

* **每个光源只影响覆盖的屏幕 tile**
* 不再与 draw call / geometry 数量耦合
* 不再在 fragment shader 里 loop lights

于是 cost 变成：

```
Cost ≈ GBuffer write + Σ (light volume 覆盖像素)
```

当你降分辨率时：

* GBuffer 带宽 ↓
* light pass 像素数 ↓
* tile/cluster 数 ↓

这是**非常干净的比例缩放**。

---

### 2. 延迟的光照结果更“可超分”

原因有三个：

1. **光照在屏幕空间**

   * 可用历史信息
   * 可用 motion vector
2. **法线 / 深度是连续信号**

   * 对超分友好
3. **光照频率低于几何频率**

   * 尤其是 diffuse

所以手机端常见策略是：

* GBuffer 0.5× / 0.67×
* Lighting 同分辨率
* 最终 upsample + sharpen / TAAU

效果可控，收益稳定。

---

## 四、前向能不能“变得像延迟”？——工程上的妥协方案

现实里前向并非完全没救，但你会发现它**正在被改造成“类延迟”**。

### 1. Forward+ / Clustered Forward

* 先在 compute 中：

  * screen-space tile / cluster
  * light list
* fragment shader：

  * 只 loop 本 tile 的 lights

这已经是：

> **延迟 lighting 的 light culling + 前向 shading**

但问题在移动端：

* light list 访问 = 带宽
* cluster buffer = cache miss
* ALU / LDS / register 压力仍然高

所以 Forward+ 在 **10–30 盏灯** 尚可
**50+ 动态点光** 依然输给延迟。

---

### 2. 混合路径（手游常用）

常见做法：

* 主光 / 少量关键点光：前向
* 次要点光 / 装饰光：延迟 or baked
* specular light 限制数量
* per-object light cap（例如 4 lights）

这本质是：

> **人为限制前向的“光源维度”**

---

## 五、带宽不是瓶颈？这是一个“错觉”

你提到：

> “延迟低分辨率后，带宽感觉也不是大问题了”

这在**低分辨率**成立，但前向的真实问题是：

* **寄存器压力**
* **指令依赖**
* **光照 loop 造成的指令发散**

移动 GPU（特别是 Mali / Adreno）：

* ALU:BW ≈ 高
* 但 **长 fragment shader 极其不友好**
* 多点光 = wave 内 divergence

所以：

* 延迟：多 pass，短 shader，cache 友好
* 前向：单 pass，长 shader，吞吐差

---

## 六、一句话总结（可直接用于技术讨论）

> 低分辨率 + 超分只能解决“每像素算一次”的问题，
> **解决不了“每像素要算多少次光”的问题。**
>
> 延迟渲染把“光源维度”转移到了屏幕空间，使光照复杂度随分辨率线性缩放；
> 前向渲染即使降分辨率，多点光的计算复杂度仍然随光源数量爆炸。

如果你愿意，我可以进一步从 **Mali / Adreno 的执行模型**、
或者用一个 **公式级别的成本模型**，精确对比 Forward / Forward+ / Deferred 在移动端的拐点位置。
