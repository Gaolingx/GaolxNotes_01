# é«˜æ•ˆé«˜æ–¯æ¨¡ç³Šä¼˜åŒ–æŠ€å·§

### ğŸ§‘â€ğŸ’» User

```
// BloomBlur.compute
// Copied & modified from ColorPyramid.compute

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma kernel KMain          MAIN=KMain
#pragma kernel KDownsample    MAIN=KDownsample  DOWNSAMPLE


TEXTURE2D_X(_InputTexture);

RW_TEXTURE2D_X(float3, _OutputTexture);

SAMPLER(sampler_LinearClamp);

CBUFFER_START(cb0)
    float4 _TexelSize;       // xy: size, zw: texel size
CBUFFER_END

// 16x16 pixels with an 8x8 center that we will be blurring writing out. Each uint is two color
// channels packed together.
// The reason for separating channels is to reduce bank conflicts in the local data memory
// controller. A large stride will cause more threads to collide on the same memory bank.
groupshared uint gs_cacheR[128];
groupshared uint gs_cacheG[128];
groupshared uint gs_cacheB[128];

float3 BlurPixels(float3 a, float3 b, float3 c, float3 d, float3 e, float3 f, float3 g, float3 h, float3 i)
{
    return 0.27343750 * (e    )
         + 0.21875000 * (d + f)
         + 0.10937500 * (c + g)
         + 0.03125000 * (b + h)
         + 0.00390625 * (a + i);
}

void Store2Pixels(uint index, float3 pixel1, float3 pixel2)
{
    gs_cacheR[index] = f32tof16(pixel1.r) | f32tof16(pixel2.r) << 16;
    gs_cacheG[index] = f32tof16(pixel1.g) | f32tof16(pixel2.g) << 16;
    gs_cacheB[index] = f32tof16(pixel1.b) | f32tof16(pixel2.b) << 16;
}

void Load2Pixels(uint index, out float3 pixel1, out float3 pixel2)
{
    uint rr = gs_cacheR[index];
    uint gg = gs_cacheG[index];
    uint bb = gs_cacheB[index];
    pixel1 = float3(f16tof32(rr      ), f16tof32(gg      ), f16tof32(bb      ));
    pixel2 = float3(f16tof32(rr >> 16), f16tof32(gg >> 16), f16tof32(bb >> 16));
}

void Store1Pixel(uint index, float3 pixel)
{
    gs_cacheR[index] = asuint(pixel.r);
    gs_cacheG[index] = asuint(pixel.g);
    gs_cacheB[index] = asuint(pixel.b);
}

void Load1Pixel(uint index, out float3 pixel)
{
    pixel = asfloat(uint3(gs_cacheR[index], gs_cacheG[index], gs_cacheB[index]));
}

// Blur two pixels horizontally. This reduces LDS reads and pixel unpacking.
void BlurHorizontally(uint outIndex, uint leftMostIndex)
{
    float3 s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
    Load2Pixels(leftMostIndex + 0, s0, s1);
    Load2Pixels(leftMostIndex + 1, s2, s3);
    Load2Pixels(leftMostIndex + 2, s4, s5);
    Load2Pixels(leftMostIndex + 3, s6, s7);
    Load2Pixels(leftMostIndex + 4, s8, s9);

    Store1Pixel(outIndex    , BlurPixels(s0, s1, s2, s3, s4, s5, s6, s7, s8));
    Store1Pixel(outIndex + 1, BlurPixels(s1, s2, s3, s4, s5, s6, s7, s8, s9));
}

void BlurVertically(uint2 pixelCoord, uint topMostIndex)
{
    float3 s0, s1, s2, s3, s4, s5, s6, s7, s8;
    Load1Pixel(topMostIndex     , s0);
    Load1Pixel(topMostIndex +  8, s1);
    Load1Pixel(topMostIndex + 16, s2);
    Load1Pixel(topMostIndex + 24, s3);
    Load1Pixel(topMostIndex + 32, s4);
    Load1Pixel(topMostIndex + 40, s5);
    Load1Pixel(topMostIndex + 48, s6);
    Load1Pixel(topMostIndex + 56, s7);
    Load1Pixel(topMostIndex + 64, s8);

    float3 blurred = BlurPixels(s0, s1, s2, s3, s4, s5, s6, s7, s8);

    // Guard bands
    blurred *= all(pixelCoord < uint2(_TexelSize.xy));

    // Write to the final target
    _OutputTexture[COORD_TEXTURE2D_X(pixelCoord)] = blurred;
}

#define GROUP_SIZE 8

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MAIN(uint2 groupId : SV_GroupID, uint2 groupThreadId : SV_GroupThreadID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // Upper-left pixel coordinate of quad that this thread will read
    int2 threadUL = (groupThreadId << 1) + (groupId << 3) - 4;

#if DOWNSAMPLE
    float2 offset = float2(threadUL);
    float2 maxCoord = 1.0 - 0.5f *_TexelSize.zw;

    float2 uv00 = clamp((offset + 0.5) * _TexelSize.zw, 0, maxCoord);
    float2 uv10 = clamp((offset + float2(1.0, 0.0) + 0.5) * _TexelSize.zw, 0, maxCoord);
    float2 uv01 = clamp((offset + float2(0.0, 1.0) + 0.5) * _TexelSize.zw, 0, maxCoord);
    float2 uv11 = clamp((offset + float2(1.0, 1.0) + 0.5) * _TexelSize.zw, 0, maxCoord);

    float3 p00 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv00, 0.0).xyz;
    float3 p10 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv10, 0.0).xyz;
    float3 p01 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv01, 0.0).xyz;
    float3 p11 = SAMPLE_TEXTURE2D_X_LOD(_InputTexture, sampler_LinearClamp, uv11, 0.0).xyz;
#else
    uint2 uthreadUL = uint2(max(0, threadUL));
    uint2 size = uint2(_TexelSize.xy) - 1u;

    float3 p00 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 0u), size))].xyz;
    float3 p10 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 0u), size))].xyz;
    float3 p11 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(1u, 1u), size))].xyz;
    float3 p01 = _InputTexture[COORD_TEXTURE2D_X(min(uthreadUL + uint2(0u, 1u), size))].xyz;
#endif

    // Store the 4 downsampled pixels in LDS
    uint destIdx = groupThreadId.x + (groupThreadId.y << 4u);
    Store2Pixels(destIdx     , p00, p10);
    Store2Pixels(destIdx + 8u, p01, p11);

    GroupMemoryBarrierWithGroupSync();

    // Horizontally blur the pixels in LDS
    uint row = groupThreadId.y << 4u;
    BlurHorizontally(row + (groupThreadId.x << 1u), row + groupThreadId.x + (groupThreadId.x & 4u));

    GroupMemoryBarrierWithGroupSync();

    // Vertically blur the pixels in LDS and write the result to memory
    BlurVertically(dispatchThreadId.xy, (groupThreadId.y << 3u) + groupThreadId.x);
}

```
è®²è§£è¯¥kernelå®ç°æ€è·¯å’Œè¿ç”¨çš„ä¼˜åŒ–æŠ€å·§

---

### ğŸ¤– Assistant

è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ª**é«˜æ•ˆçš„é«˜æ–¯æ¨¡ç³Šï¼ˆGaussian Blurï¼‰**ï¼Œä¸“é—¨ç”¨äºBloomï¼ˆè¾‰å…‰ï¼‰æ•ˆæœçš„åå¤„ç†ã€‚å®ƒæ˜¯ä¸€ä¸ªCompute Shaderï¼Œæ˜¯ä»Unityçš„`ColorPyramid.compute`ä¿®æ”¹è€Œæ¥çš„ã€‚

å®ƒæœ€æ ¸å¿ƒçš„è®¾è®¡ç†å¿µæ˜¯åˆ©ç”¨**Compute Shaderçš„çº¿ç¨‹ç»„å…±äº«å†…å­˜ï¼ˆLDS - Local Data Shareï¼‰**æ¥æå¤§å‡å°‘å¯¹æ˜¾å­˜ï¼ˆVRAMï¼‰çš„å¸¦å®½æ¶ˆè€—ï¼Œå¹¶å°†ä¸¤æ¬¡æ¨¡ç³Šï¼ˆæ°´å¹³å’Œå‚ç›´ï¼‰åˆå¹¶åœ¨ä¸€ä¸ªKernelä¸­å®Œæˆã€‚

ä»¥ä¸‹æ˜¯è¯¦ç»†çš„å®ç°æ€è·¯å’Œä¼˜åŒ–æŠ€å·§åˆ†æï¼š

### ä¸€ã€ æ ¸å¿ƒå®ç°æ€è·¯ï¼šTile-Based Separable Blurï¼ˆåŸºäºå›¾å—çš„å¯åˆ†ç¦»æ¨¡ç³Šï¼‰

é€šå¸¸çš„é«˜æ–¯æ¨¡ç³Šæ˜¯$N \times N$çš„å·ç§¯ï¼Œè®¡ç®—é‡æå¤§ã€‚
1.  **å¯åˆ†ç¦»æ€§ï¼ˆSeparabilityï¼‰**ï¼šç®—æ³•é¦–å…ˆåˆ©ç”¨é«˜æ–¯æ ¸çš„å¯åˆ†ç¦»æ€§ï¼Œå°†äºŒç»´æ¨¡ç³Šæ‹†è§£ä¸ºâ€œå…ˆæ°´å¹³æ¨¡ç³Šï¼Œåå‚ç›´æ¨¡ç³Šâ€ã€‚è¿™ä¸ä»…å°†å¤æ‚åº¦ä» $O(R^2)$ é™ä½åˆ° $O(2R)$ï¼Œä¹Ÿä¸ºåˆ©ç”¨LDSæä¾›äº†åŸºç¡€ã€‚
2.  **åˆ†å—å¤„ç†ï¼ˆTile-Basedï¼‰**ï¼š
    *   Shaderå°†å±å¹•åˆ’åˆ†ä¸ºæ— æ•°ä¸ª $8 \times 8$ çš„å°å—ï¼ˆTileï¼‰ã€‚
    *   æ¯ä¸ªçº¿ç¨‹ç»„ï¼ˆWorkgroupï¼‰è´Ÿè´£è®¡ç®—ä¸€ä¸ª $8 \times 8$ çš„æœ€ç»ˆè¾“å‡ºåŒºåŸŸã€‚
    *   ç”±äºæ¨¡ç³Šéœ€è¦é‡‡æ ·å‘¨å›´åƒç´ ï¼ˆApron/Haloï¼‰ï¼Œä¸ºäº†è¾“å‡ºä¸­é—´ $8 \times 8$ çš„ç»“æœï¼Œçº¿ç¨‹ç»„å¿…é¡»è¯»å–æ¯” $8 \times 8$ æ›´å¤§çš„åŒºåŸŸã€‚ä»£ç ä¸­è¯»å–çš„æ˜¯ $16 \times 16$ çš„æºåƒç´ åŒºåŸŸã€‚

#### å…·ä½“æ‰§è¡Œæµç¨‹ï¼š

1.  **åŠ è½½é˜¶æ®µ (Load & Pack)**ï¼š
    *   $8 \times 8$ ä¸ªçº¿ç¨‹å¹¶è¡Œå·¥ä½œã€‚
    *   æ¯ä¸ªçº¿ç¨‹è´Ÿè´£è¯»å–æºçº¹ç†ä¸­çš„ $2 \times 2$ ä¸ªåƒç´ ï¼ˆå…±4ä¸ªåƒç´ ï¼‰ã€‚
    *   æ€»å…±è¯»å– $16 \times 16$ çš„åŒºåŸŸã€‚
    *   åˆ©ç”¨`Store2Pixels`å°†åƒç´ æ•°æ®**å‹ç¼©**å¹¶å­˜å…¥LDSï¼ˆå…±äº«å†…å­˜ï¼‰ã€‚

2.  **æ°´å¹³æ¨¡ç³Šé˜¶æ®µ (Horizontal Blur)**ï¼š
    *   `GroupMemoryBarrierWithGroupSync()` ç¡®ä¿æ‰€æœ‰åƒç´ åŠ è½½å®Œæ¯•ã€‚
    *   çº¿ç¨‹ä»LDSè¯»å–æ•°æ®ï¼Œè¿›è¡Œæ°´å¹³æ–¹å‘çš„9-tapï¼ˆ9ä¸ªé‡‡æ ·ç‚¹ï¼‰é«˜æ–¯æ¨¡ç³Šã€‚
    *   ç”±äºæ¨¡ç³Šæ ¸åŠå¾„ä¸º4ï¼Œè¾“å…¥å®½åº¦16çš„åƒç´ è¡Œï¼Œç»è¿‡æ¨¡ç³Šåï¼Œåªæœ‰ä¸­é—´çš„8ä¸ªåƒç´ æ˜¯â€œæœ‰æ•ˆâ€çš„ï¼ˆä¸¤è¾¹å„ä¸¢å¼ƒ4ä¸ªè¾¹ç¼˜åƒç´ ï¼‰ã€‚
    *   ç»“æœï¼ˆ$8 \times 16$ ä¸ªåƒç´ ï¼‰è¢«å†™å›LDSã€‚æ­¤æ—¶LDSä¸­çš„æ•°æ®ç»“æ„å‘ç”Ÿå˜åŒ–ï¼ˆä»å‹ç¼©çš„FP16å˜æˆäº†éå‹ç¼©çš„FP32ï¼Œä½†æ•°é‡å‡åŠï¼Œåˆšå¥½å¡«æ»¡ï¼‰ã€‚

3.  **å‚ç›´æ¨¡ç³Šä¸è¾“å‡ºé˜¶æ®µ (Vertical Blur & Write)**ï¼š
    *   `GroupMemoryBarrierWithGroupSync()` ç¡®ä¿æ°´å¹³æ¨¡ç³Šå®Œæˆã€‚
    *   çº¿ç¨‹ä»LDSè¯»å–ç»è¿‡æ°´å¹³æ¨¡ç³Šçš„æ•°æ®ï¼Œè¿›è¡Œå‚ç›´æ–¹å‘çš„9-tapæ¨¡ç³Šã€‚
    *   è¾“å…¥é«˜åº¦16çš„åƒç´ åˆ—ï¼Œç»è¿‡æ¨¡ç³Šåï¼Œå¾—åˆ°ä¸­é—´8ä¸ªæœ‰æ•ˆåƒç´ ã€‚
    *   æœ€ç»ˆå¾—åˆ° $8 \times 8$ çš„ç»“æœï¼Œç›´æ¥å†™å…¥ `_OutputTexture`ã€‚

---

### äºŒã€ è¿ç”¨çš„å…³é”®ä¼˜åŒ–æŠ€å·§

è¿™ä¸ªShaderåŒ…å«äº†å¾ˆå¤šé’ˆå¯¹GPUæ¶æ„ï¼ˆç‰¹åˆ«æ˜¯GCN/RDNAæ¶æ„æˆ–é€šç”¨çš„Computeæ¶æ„ï¼‰çš„åº•å±‚ä¼˜åŒ–ï¼š

#### 1. åˆ©ç”¨LDSå‡å°‘æ˜¾å­˜å¸¦å®½ï¼ˆæœ€å…³é”®çš„ä¼˜åŒ–ï¼‰
*   **ä¼ ç»Ÿåšæ³•**ï¼šæ°´å¹³æ¨¡ç³Šï¼ˆRead VRAM -> Write VRAMï¼‰ -> å‚ç›´æ¨¡ç³Šï¼ˆRead VRAM -> Write VRAMï¼‰ã€‚æ¯ä¸ªåƒç´ è¢«è¯»å†™å¤šæ¬¡ã€‚
*   **æ­¤åšæ³•**ï¼šRead VRAM (ä¸€æ¬¡) -> LDSæ“ä½œ (å¤šæ¬¡) -> Write VRAM (ä¸€æ¬¡)ã€‚
*   LDSçš„è¯»å†™é€Ÿåº¦è¿œå¿«äºVRAMï¼Œä¸”å‡ ä¹æ²¡æœ‰å»¶è¿Ÿã€‚é€šè¿‡åœ¨LDSä¸­å®Œæˆä¸­é—´çš„æ°´å¹³æ¨¡ç³Šå¹¶ä¼ é€’ç»™å‚ç›´æ¨¡ç³Šï¼ŒèŠ‚çœäº†ä¸­é—´äº§ç”Ÿçš„å·¨å¤§å¸¦å®½ã€‚

#### 2. å·§å¦™çš„LDSå†…å­˜å¤ç”¨ä¸æ•°æ®æ‰“åŒ… (Packing)
*   **FP16 æ‰“åŒ…**ï¼šä»£ç ä½¿ç”¨äº† `f32tof16` å°†ä¸¤ä¸ª32ä½æµ®ç‚¹é¢œè‰²ï¼ˆfloatï¼‰æ‰“åŒ…è¿›ä¸€ä¸ª `uint`ï¼ˆ32ä½æ•´æ•°ï¼‰ä¸­ã€‚
    *   `Load2Pixels` / `Store2Pixels`ï¼šä¸¤ä¸ªåƒç´ çš„Ré€šé“æ‹¼åœ¨ä¸€èµ·ï¼ŒGæ‹¼åœ¨ä¸€èµ·ï¼ŒBæ‹¼åœ¨ä¸€èµ·ã€‚
    *   **åŸå› **ï¼šLDSçš„å¤§å°æ˜¯æœ‰é™çš„ï¼ˆè¿™é‡Œå®šä¹‰ä¸º128ä¸ªå…ƒç´ ï¼‰ã€‚
        *   **è¾“å…¥é˜¶æ®µ**ï¼šéœ€è¦å­˜å‚¨ $16 \times 16 = 256$ ä¸ªåƒç´ ã€‚å¦‚æœä¸æ‰“åŒ…ï¼Œå­˜ä¸ä¸‹ã€‚æ‰“åŒ…åå ç”¨ $256 / 2 = 128$ ä¸ªæ§½ä½ï¼Œå®Œç¾é€‚é…ã€‚
        *   **ä¸­é—´é˜¶æ®µ**ï¼šæ°´å¹³æ¨¡ç³Šåï¼Œä¸ä»…ä¸éœ€è¦ä¸¤è¾¹çš„è¾¹ç¼˜æ•°æ®ï¼Œæœ‰æ•ˆæ•°æ®å˜æˆäº† $8 \text{ (å®½)} \times 16 \text{ (é«˜)} = 128$ ä¸ªåƒç´ ã€‚æ­¤æ—¶ä¸éœ€è¦æ‰“åŒ…ï¼Œç›´æ¥å­˜float32ï¼ˆ`Store1Pixel`ï¼‰ï¼Œä¾ç„¶æ˜¯128ä¸ªæ§½ä½ï¼Œå®Œç¾å¤ç”¨åŒä¸€å—å†…å­˜ã€‚

#### 3. é¿å…LDS Bank Conflictï¼ˆå­˜å‚¨ä½“å†²çªï¼‰
*   ä»£ç å®šä¹‰äº†ä¸‰ä¸ªç‹¬ç«‹çš„æ•°ç»„ï¼š`gs_cacheR`, `gs_cacheG`, `gs_cacheB`ï¼Œè€Œä¸æ˜¯å®šä¹‰ä¸€ä¸ª `struct { r, g, b } gs_cache[]`ã€‚
*   è¿™æ˜¯ä¸€ç§ **Structure of Arrays (SoA)** çš„å¸ƒå±€ã€‚åœ¨GPUä¸Šï¼Œå¦‚æœè¿ç»­çš„çº¿ç¨‹è®¿é—®è¿ç»­çš„LDSåœ°å€ï¼Œé€šå¸¸å¾ˆå¿«ã€‚ä½†å¦‚æœå­˜å–è·¨åº¦å¤§æˆ–è€…äº¤é”™ï¼Œä¼šå¯¼è‡´Bank Conflictã€‚å°†RGBåˆ†å¼€å­˜å‚¨ï¼Œæœ‰åŠ©äºç¡®ä¿çº¿ç¨‹åœ¨è¯»å–åŒä¸€é¢œè‰²é€šé“æ—¶ï¼Œè®¿é—®æ¨¡å¼æ›´è§„æ•´ï¼Œå‡å°‘å†²çªæ¦‚ç‡ã€‚

#### 4. å‘é‡åŒ–ä¸æŒ‡ä»¤çº§å¹¶è¡Œ (Instruction Level Parallelism)
*   **æ°´å¹³æ¨¡ç³Š**ï¼š`BlurHorizontally` å‡½æ•°ä¸€æ¬¡è®¡ç®—**2ä¸ª**è¾“å‡ºåƒç´ ã€‚
    *   å®ƒåŠ è½½10ä¸ªæºåƒç´ ï¼Œè®¡ç®—2ä¸ªç»“æœã€‚è¿™æ¯”è®¡ç®—1ä¸ªåƒç´ åŠ è½½9ä¸ªæºæ•°æ®è¦é«˜æ•ˆï¼Œå› ä¸ºè¿™2ä¸ªç»“æœå…±äº«äº†ä¸­é—´çš„8ä¸ªé‡‡æ ·ç‚¹æ•°æ®ï¼ˆæ•°æ®å¤ç”¨ï¼‰ï¼Œå‡å°‘äº†LDSè¯»å–æ¬¡æ•°å’Œå¯„å­˜å™¨å‹åŠ›ã€‚

#### 5. åŒçº¿æ€§æ’å€¼ä¼˜åŒ–çš„é™é‡‡æ · (Downsample Optimization)
*   åœ¨ `DOWNSAMPLE` å®å¼€å¯æ—¶ï¼ˆ`KDownsample`ï¼‰ï¼Œä»£ç å¹¶ä¸ä»…ä»…æ˜¯è¯»å–åƒç´ ï¼Œè€Œæ˜¯ä½¿ç”¨ `SAMPLE_TEXTURE2D_X_LOD` è¿›è¡Œé‡‡æ ·ã€‚
*   é€šè¿‡è®¡ç®— `uv00`, `uv10` ç­‰åæ ‡ï¼Œå®ƒåˆ©ç”¨GPUçš„**çº¹ç†æ˜ å°„å•å…ƒ (TMU)** ç¡¬ä»¶è‡ªå¸¦çš„åŒçº¿æ€§æ’å€¼åŠŸèƒ½æ¥å®Œæˆåˆæ­¥çš„â€œå¹³å‡â€æ“ä½œã€‚è¿™ç›¸å½“äºåœ¨è¿›è¡Œæ¨¡ç³Šå‰å…ˆâ€œå…è´¹â€åšäº†ä¸€æ¬¡ $2 \times 2$ çš„å¹³å‡é™é‡‡æ ·ï¼Œæ¯”åœ¨Shaderé‡Œæ‰‹åŠ¨å†™ALUä»£ç å»å¹³å‡4ä¸ªåƒç´ è¦å¿«å¾—å¤šã€‚

#### 6. æ¯ä¸€ä¸ªçº¿ç¨‹å¤„ç† $2 \times 2$ åƒç´ 
*   çº¿ç¨‹ç»„å¤§å°æ˜¯ $8 \times 8$ï¼ˆ64ä¸ªçº¿ç¨‹ï¼‰ï¼Œä½†å¤„ç†çš„è¾“å…¥è¦†ç›–äº† $16 \times 16$ï¼ˆ256ä¸ªåƒç´ ï¼‰ã€‚
*   æ¯ä¸ªçº¿ç¨‹è´Ÿè´£åŠ è½½å’Œå­˜å‚¨ $2 \times 2$ çš„å—ã€‚è¿™ç§ç²’åº¦ï¼ˆGranularityï¼‰æ¯”â€œä¸€çº¿ç¨‹ä¸€åƒç´ â€æ›´èƒ½æ©ç›–å†…å­˜å»¶è¿Ÿï¼Œå¹¶æé«˜æŒ‡ä»¤å‘å°„æ•ˆç‡ã€‚

### æ€»ç»“

è¿™æ®µä»£ç æ˜¯**è®¡ç®—ç€è‰²å™¨ä¼˜åŒ–çš„æ•™ç§‘ä¹¦å¼æ¡ˆä¾‹**ã€‚å®ƒæ²¡æœ‰ç®€å•åœ°æŠŠé«˜æ–¯æ¨¡ç³Šå…¬å¼ç¿»è¯‘æˆä»£ç ï¼Œè€Œæ˜¯æ·±åº¦ç»“åˆäº†GPUç¡¬ä»¶ç‰¹æ€§ï¼š
1.  ç”¨ **LDS** æ¢å– **VRAMå¸¦å®½**ã€‚
2.  ç”¨ **è®¡ç®—é€»è¾‘ï¼ˆæ‰“åŒ…/è§£åŒ…ï¼‰** æ¢å– **LDSç©ºé—´**ã€‚
3.  ç”¨ **SoAå¸ƒå±€** æ¢å– **Bankè®¿é—®æ•ˆç‡**ã€‚
4.  ç”¨ **TMUç¡¬ä»¶æ’å€¼** æ¢å– **ALUè¿ç®—é‡**ã€‚