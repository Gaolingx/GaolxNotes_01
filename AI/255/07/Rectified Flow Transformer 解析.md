# Rectified Flow Transformer è§£æ

### ğŸ§‘â€ğŸ’» User

Rectified flow Transformer in latent t2iæ¨¡å‹å¦‚ä½•è§£å†³ditåªèƒ½ç”Ÿæˆå›ºå®šåˆ†è¾¨ç‡ï¼ˆä¾‹å¦‚å›ºå®šçŸ­è¾¹ï¼‰å›¾åƒï¼Œæå‡è¶…åˆ†è¾¨ç‡ï¼ˆç›¸å¯¹è®­ç»ƒæ•°æ®é›†ï¼‰æ³›åŒ–èƒ½åŠ›ï¼Ÿ

---

### ğŸ¤– Assistant

Rectified Flow (RF) æ˜¯ä¸€ç§è®­ç»ƒç›®æ ‡ï¼ˆTraining Objectiveï¼‰å’Œé‡‡æ ·æ–¹æ³•ï¼Œè€Œ DiT (Diffusion Transformer) æ˜¯ä¸€ç§ç½‘ç»œæ¶æ„ã€‚è¦è§£å†³ DiT åªèƒ½ç”Ÿæˆå›ºå®šåˆ†è¾¨ç‡çš„é—®é¢˜ï¼Œå¹¶æå‡è¶…åˆ†è¾¨ç‡ï¼ˆSuper-Resolutionï¼‰æ³›åŒ–èƒ½åŠ›ï¼Œå…³é”®ä¸åœ¨äº RF æœ¬èº«ï¼Œè€Œåœ¨äº **DiT æ¶æ„ä¸­ä½ç½®ç¼–ç ï¼ˆPositional Embedding, PEï¼‰çš„è®¾è®¡** ä»¥åŠ **æ¨ç†æ—¶çš„åºåˆ—å¤„ç†ç­–ç•¥**ã€‚

ç»“åˆæœ€æ–°çš„ç ”ç©¶æˆæœï¼ˆå¦‚ Stable Diffusion 3, Flux.1, Lumina-T2I ç­‰åŸºäº RF/Flow Matching çš„æ¨¡å‹ï¼‰ï¼Œä»¥ä¸‹æ˜¯è§£å†³è¯¥é—®é¢˜çš„æ ¸å¿ƒæŠ€æœ¯æ–¹æ¡ˆï¼š

### 1. æ ¸å¿ƒç—›ç‚¹ï¼šç»å¯¹ä½ç½®ç¼–ç çš„å±€é™æ€§

ä¼ ç»Ÿçš„ ViT æˆ– DiT ä½¿ç”¨**ç»å¯¹ä½ç½®ç¼–ç  (Absolute Learnable PE)** æˆ–å›ºå®šçš„ **Sinusoidal PE**ã€‚å¦‚æœåœ¨è®­ç»ƒæ—¶å›¾åƒè¢«è£å‰ªä¸º $256 \times 256$ï¼ˆå³ $32 \times 32$ ä¸ª Patchï¼‰ï¼Œæ¨¡å‹å°±åªèƒ½å­¦ä¼šå¤„ç†é•¿åº¦ä¸º 1024 çš„åºåˆ—ã€‚å½“æ¨ç†æ—¶è¾“å…¥ $512 \times 512$ çš„å›¾åƒï¼ˆ4096 ä¸ª Patchï¼‰ï¼Œä½ç½®ç¼–ç æ— æ³•è¦†ç›–æˆ–ç›´æ¥å¤–æ¨ï¼Œå¯¼è‡´å›¾åƒå´©åæˆ–é‡å¤çº¹ç†ã€‚

### 2. è§£å†³æ–¹æ¡ˆä¸€ï¼šäºŒç»´æ—‹è½¬ä½ç½®ç¼–ç  (2D RoPE)

è¿™æ˜¯ç›®å‰è§£å†³ Transformer ä»»æ„åˆ†è¾¨ç‡é—®é¢˜çš„â€œé»„é‡‘æ ‡å‡†â€ï¼ˆè¢« SD3, Flux ç­‰æ¨¡å‹é‡‡ç”¨ï¼‰ã€‚

#### æœºåˆ¶åŸç†
**RoPE (Rotary Positional Embeddings)** é€šè¿‡æ—‹è½¬çŸ©é˜µå°†ä½ç½®ä¿¡æ¯æ³¨å…¥åˆ° Query å’Œ Key ä¸­ï¼Œä½¿å¾—æ³¨æ„åŠ›åˆ†æ•°ä»…ä¾èµ–äºç›¸å¯¹è·ç¦»ã€‚å¯¹äºå›¾åƒï¼Œä½¿ç”¨çš„æ˜¯ **2D RoPE**ï¼ˆåˆ†åˆ«å¯¹ $x$ è½´å’Œ $y$ è½´åº”ç”¨ RoPEï¼‰ã€‚

#### è§£å†³è¶…åˆ†è¾¨ç‡æ³›åŒ–
å½“æ¨ç†åˆ†è¾¨ç‡è¶…è¿‡è®­ç»ƒåˆ†è¾¨ç‡æ—¶ï¼Œä¸å†æ˜¯ç®€å•çš„â€œå¤–æ¨â€ï¼ˆExtrapolationï¼‰ï¼Œè€Œæ˜¯é€šè¿‡**é¢‘ç‡æ’å€¼**æˆ–**åæ ‡ç¼©æ”¾**ï¼š

1.  **åæ ‡ç¼©æ”¾ (Coordinate Scaling):**
    å‡è®¾è®­ç»ƒæ—¶æœ€å¤§ Latent å°ºå¯¸ä¸º $H_{train} \times W_{train}$ã€‚æ¨ç†æ—¶éœ€è¦ç”Ÿæˆ $H_{infer} \times W_{infer}$ã€‚
    ä¸ä½¿ç”¨è¶…å‡ºè®­ç»ƒèŒƒå›´çš„åæ ‡ï¼ˆå¦‚ $0, 1, ..., N$ï¼‰ï¼Œè€Œæ˜¯å°†æ¨ç†æ—¶çš„åæ ‡ç¼©æ”¾åˆ°è®­ç»ƒèŒƒå›´å†…ï¼š
    $$
    pos'_{infer} = pos_{infer} \times \frac{H_{train}}{H_{infer}}
    $$
    è¿™æœ¬è´¨ä¸Šæ˜¯å°†é«˜åˆ†è¾¨ç‡å›¾åƒçœ‹ä½œæ˜¯è®­ç»ƒåˆ†è¾¨ç‡å›¾åƒçš„â€œæ›´å¯†é›†é‡‡æ ·â€ã€‚

2.  **NTK-Aware Interpolation:**
    ç›´æ¥çº¿æ€§æ’å€¼å¯èƒ½ä¼šä¸¢å¤±é«˜é¢‘ä¿¡æ¯ã€‚å€Ÿé‰´ LLM ä¸­çš„ NTK-Aware Scaled RoPEï¼Œå¯ä»¥åœ¨ä¿æŒä½é¢‘ä¿¡æ¯ç›¸å¯¹ä¸å˜çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€è°ƒæ•´é«˜é¢‘åˆ†é‡çš„åŸºé¢‘ï¼Œä»è€Œåœ¨ä¸é‡æ–°è®­ç»ƒçš„æƒ…å†µä¸‹æ”¯æŒæ›´é•¿çš„åºåˆ—ï¼ˆæ›´é«˜åˆ†è¾¨ç‡ï¼‰ã€‚

### 3. è§£å†³æ–¹æ¡ˆäºŒï¼šPatch Packing (å¯å˜åºåˆ—é•¿åº¦è®­ç»ƒ)

ä¸ºäº†è®©æ¨¡å‹åœ¨è®­ç»ƒé˜¶æ®µå°±é€‚åº”ä¸åŒçš„é•¿å®½æ¯”å’Œåˆ†è¾¨ç‡ï¼Œä¸èƒ½ä½¿ç”¨ç®€å•çš„ Paddingï¼ˆå¡«å……ï¼‰ï¼Œè€Œæ˜¯ä½¿ç”¨ **Packing** æŠ€æœ¯ã€‚

*   **NaÃ¯ve æ–¹æ³•:** å°†æ‰€æœ‰å›¾åƒ Resize åˆ°å›ºå®šæ­£æ–¹å½¢ï¼ˆç ´åé•¿å®½æ¯”ï¼‰æˆ– Pad åˆ°æœ€å¤§å°ºå¯¸ï¼ˆè®¡ç®—æµªè´¹ï¼Œä¸”æ¨¡å‹å­¦åˆ° Padding ç‰¹å¾ï¼‰ã€‚
*   **Packing æ–¹æ³•:**
    1.  å°†ä¸åŒåˆ†è¾¨ç‡å’Œé•¿å®½æ¯”çš„å›¾åƒè½¬æ¢ä¸º Patch åºåˆ—ã€‚
    2.  å°†è¿™äº› Patch æ‹¼æ¥æˆä¸€ä¸ªè¶…é•¿çš„ 1D åºåˆ—ã€‚
    3.  **Block Diagonal Masking (å—å¯¹è§’æ©ç ):** åœ¨ Self-Attention ä¸­ï¼Œç¡®ä¿å›¾åƒ A çš„ Token åªèƒ½çœ‹åˆ°å›¾åƒ A çš„ Tokenï¼Œçœ‹ä¸åˆ°å›¾åƒ B çš„ã€‚

é€šè¿‡è¿™ç§ **Multi-Resolution / Multi-Aspect-Ratio Bucket Training**ï¼Œæ¨¡å‹å¤©ç”Ÿå°±ä¸å†ä¾èµ–å›ºå®šçš„ $H \times W$ï¼Œè€Œæ˜¯ä¾èµ–â€œåºåˆ—çš„å±€éƒ¨å…³ç³»â€ã€‚

### 4. è§£å†³æ–¹æ¡ˆä¸‰ï¼šåˆ†è¾¨ç‡æ¡ä»¶æ³¨å…¥ (Resolution Conditioning)

ä¸ºäº†è®©æ¨¡å‹â€œçŸ¥é“â€å®ƒæ­£åœ¨ç”Ÿæˆè¶…é«˜åˆ†è¾¨ç‡å›¾åƒï¼Œæ˜¾å¼åœ°å°†åˆ†è¾¨ç‡ä½œä¸ºæ¡ä»¶è¾“å…¥ã€‚

*   **åŸç†:** å®šä¹‰ä¸€ä¸ª MLP å°† $(H, W, AspectRatio)$ æ˜ å°„ä¸º Embeddingï¼Œå¹¶å°†å…¶æ·»åŠ åˆ° TimeStep Embedding ä¸­ï¼Œæˆ–è€…ä½œä¸º AdaLN (Adaptive Layer Norm) çš„è¾“å…¥ã€‚
*   **è¶…åˆ†æ³›åŒ–:** åœ¨æ¨ç†æ—¶ï¼Œå³ä½¿ç”¨æˆ·æƒ³è¦ç”Ÿæˆ $2048 \times 2048$ çš„å›¾åƒï¼ˆè¶…è¿‡è®­ç»ƒé›†ï¼‰ï¼Œæ¨¡å‹é€šè¿‡ RoPE æ³›åŒ–å¤„ç†åºåˆ—é•¿åº¦ï¼ŒåŒæ—¶é€šè¿‡ Conditioning çŸ¥é“â€œè¿™æ˜¯ä¸€å¼ å¤§å›¾â€ï¼Œä»è€Œè°ƒæ•´ç”Ÿæˆçš„ç»†èŠ‚å¯†åº¦ï¼Œé¿å…å‡ºç°ä»…ä»…æ˜¯æŠŠå°å›¾æ”¾å¤§çš„æ¨¡ç³Šæ„Ÿã€‚

### 5. è§£å†³æ–¹æ¡ˆå››ï¼šNoise Schedule Shift (é’ˆå¯¹ RF çš„è°ƒæ•´)

è¿™æ˜¯ä¸“é—¨é’ˆå¯¹ Rectified Flow æˆ– Diffusion åœ¨é«˜åˆ†è¾¨ç‡ç”Ÿæˆæ—¶çš„å…³é”®è°ƒæ•´ã€‚

**é—®é¢˜:** å›¾åƒåˆ†è¾¨ç‡è¶Šé«˜ï¼Œä¿¡æ¯å†—ä½™åº¦è¶Šé«˜ï¼Œä¿¡å™ªæ¯”ï¼ˆSNRï¼‰çš„æ„ŸçŸ¥ä¹Ÿä¼šå‘ç”Ÿå˜åŒ–ã€‚å¦‚æœç›´æ¥å¥—ç”¨è®­ç»ƒæ—¶çš„ Noise Scheduleï¼ˆå™ªå£°è®¡åˆ’ï¼‰ï¼Œé«˜åˆ†è¾¨ç‡ç”Ÿæˆå¾€å¾€ä¼šå‡ºç°å™ªç‚¹æœªå®Œå…¨å»é™¤æˆ–ç»“æ„é”™è¯¯ã€‚

**è§£å†³:** æ ¹æ®åˆ†è¾¨ç‡åŠ¨æ€è°ƒæ•´å™ªå£°è°ƒåº¦çš„ **Shift** å‚æ•°ã€‚

åœ¨ SD3 çš„è®ºæ–‡ä¸­ï¼Œå¯¹äº Rectified Flowï¼Œæ—¶é—´æ­¥ $t$ çš„é‡‡æ ·å¯ä»¥é€šè¿‡ Shift è¿›è¡Œè°ƒæ•´ã€‚å¯¹äºé«˜åˆ†è¾¨ç‡å›¾åƒï¼Œæˆ‘ä»¬éœ€è¦è®©æ¨¡å‹åœ¨â€œé«˜å™ªå£°â€åŒºåŸŸåœç•™æ›´ä¹…ï¼ˆbias towards noiseï¼‰ã€‚

$$
t' = \frac{\exp(s) \cdot t}{\exp(s) \cdot t + (1-t)}
$$

å…¶ä¸­ $s$ æ˜¯ä¸å›¾åƒåƒç´ æ€»æ•°ï¼ˆResolutionï¼‰ç›¸å…³çš„ç¼©æ”¾å› å­ã€‚
$$
s = \log \left( \frac{H \cdot W}{H_{train} \cdot W_{train}} \right)
$$
é€šè¿‡è¿™ç§ **Resolution-dependent Logit Normal Sampling** æˆ–ç®€å•çš„ **Time Shift**ï¼Œå¯ä»¥ç¡®ä¿åœ¨é«˜åˆ†è¾¨ç‡ä¸‹ï¼ŒRF çš„ ODE è½¨è¿¹æ›´åŠ ç¨³å®šã€‚

### 6. æ€»ç»“ä¸ä»£ç ç¤ºä¾‹ç»“æ„

ç»¼åˆä¸Šè¿°æ–¹æ¡ˆï¼Œä¸€ä¸ªå…·å¤‡è¶…åˆ†è¾¨ç‡æ³›åŒ–èƒ½åŠ›çš„ Rectified Flow DiT çš„æ ¸å¿ƒæ¨¡å—å¦‚ä¸‹ï¼š

```python
import torch
import torch.nn as nn

class RobustRF_DiT(nn.Module):
    def __init__(self, patch_size=2, embed_dim=1152):
        super().__init__()
        self.patch_size = patch_size
        # ä¸ä½¿ç”¨ nn.Embedding(max_pos)
        # è€Œæ˜¯ä½¿ç”¨ RoPE åŠ¨æ€è®¡ç®—
      
    def forward(self, x, t, resolution_cond):
        """
        x: Latent input [Batch, Channels, H, W]
        t: Timestep
        resolution_cond: Original size [H, W]
        """
        B, C, H, W = x.shape
      
        # 1. Patchify
        # å˜æˆåºåˆ— [Batch, Seq_Len, Dim]
        x = self.patchify(x) 
      
        # 2. ç”Ÿæˆ 2D Grid åæ ‡
        grid_h = torch.arange(H, device=x.device)
        grid_w = torch.arange(W, device=x.device)
      
        # 3. å…³é”®ï¼šè¶…åˆ†æ³›åŒ–æ—¶çš„åæ ‡ç¼©æ”¾ (RoPE Interpolation)
        # å¦‚æœå½“å‰ H > train_max_Hï¼Œåˆ™å‹ç¼©åæ ‡é—´è·ï¼Œä½¿å…¶è½åœ¨è®­ç»ƒè¿‡çš„é¢‘ç‡èŒƒå›´å†…
        if H > self.train_max_H:
            grid_h = grid_h * (self.train_max_H / H)
        if W > self.train_max_W:
            grid_w = grid_w * (self.train_max_W / W)
          
        # 4. åº”ç”¨ 2D RoPE åˆ° Attention å±‚
        # ... (åœ¨ Transformer Block å†…éƒ¨åº”ç”¨)
      
        # 5. æ³¨å…¥åˆ†è¾¨ç‡æ¡ä»¶
        # è®©æ¨¡å‹çŸ¥é“è™½ç„¶åæ ‡è¢«ç¼©æ”¾äº†ï¼Œä½†å®é™…åƒç´ å¾ˆå¤§
        res_emb = self.res_mlp(resolution_cond) 
        t_emb = self.time_mlp(t) + res_emb
      
        # 6. Transformer Blocks
        out = self.blocks(x, t_emb, rore_grid=(grid_h, grid_w))
      
        return self.unpatchify(out, H, W)
```

### ç»“è®º

Rectified Flow DiT æ¨¡å‹é€šè¿‡ä»¥ä¸‹ç»„åˆæ‹³è§£å†³å›ºå®šåˆ†è¾¨ç‡é™åˆ¶å¹¶æå‡è¶…åˆ†æ³›åŒ–ï¼š

1.  **æ¶æ„å±‚é¢:** æŠ›å¼ƒç»å¯¹ä½ç½®ç¼–ç ï¼Œé‡‡ç”¨ **2D RoPE** é…åˆ **é¢‘ç‡æ’å€¼/åæ ‡ç¼©æ”¾**ã€‚
2.  **æ•°æ®å±‚é¢:** é‡‡ç”¨ **Multi-Resolution Bucketing** å’Œ **Sequence Packing** è¿›è¡Œå˜é•¿åºåˆ—è®­ç»ƒã€‚
3.  **æ¡ä»¶å±‚é¢:** æ˜¾å¼æ³¨å…¥ **åˆ†è¾¨ç‡/é•¿å®½æ¯” Embedding**ã€‚
4.  **é‡‡æ ·å±‚é¢:** æ ¹æ®åˆ†è¾¨ç‡è°ƒæ•´ **Time Schedule (Shift)**ï¼Œé€‚åº”é«˜åˆ†è¾¨ç‡ä¸‹çš„ä¿¡å™ªæ¯”å˜åŒ–ã€‚

ç›®å‰æœ€å…ˆè¿›çš„å¼€æºæ¨¡å‹ï¼ˆå¦‚ Flux.1 å’Œ SD3ï¼‰æ­£æ˜¯é‡‡ç”¨äº†è¿™äº›æŠ€æœ¯çš„é›†åˆä½“ã€‚