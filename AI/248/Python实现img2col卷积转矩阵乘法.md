# Pythonå®ç°img2colå·ç§¯è½¬çŸ©é˜µä¹˜æ³•

### ğŸ§‘â€ğŸ’» User

åœ¨pythonä¸­ï¼Œå¦‚ä½•é€šè¿‡ img2col ç®—æ³•å°†å·ç§¯å˜æ¢ä¸ºçŸ©é˜µä¹˜æ³•ï¼Ÿï¼ˆå¯ä½¿ç”¨numpyç­‰åŸºç¡€åº“ï¼Œä¸ä½¿ç”¨pytorchã€tensorflowç­‰æœºå™¨å­¦ä¹ æ¡†æ¶ï¼‰

---

### ğŸ¤– Assistant

å¥½çš„ï¼Œæˆ‘ä»¬æ¥è¯¦ç»†æ¢è®¨ä¸€ä¸‹å¦‚ä½•åœ¨ Python ä¸­ä»…ä½¿ç”¨ NumPy ç­‰åŸºç¡€åº“ï¼Œé€šè¿‡ `img2col` ç®—æ³•å°†å·ç§¯è¿ç®—è½¬æ¢ä¸ºçŸ©é˜µä¹˜æ³•ï¼ˆGEMM - General Matrix Multiplicationï¼‰ã€‚

### æ ¸å¿ƒæ€æƒ³ï¼šä¸ºä»€ä¹ˆè¦è½¬æ¢ï¼Ÿ

åœ¨æ·±å…¥ä»£ç ä¹‹å‰ï¼Œç†è§£â€œä¸ºä»€ä¹ˆâ€è¿™ä¹ˆåšè‡³å…³é‡è¦ã€‚

1.  **æ€§èƒ½**ï¼šç›´æ¥ç”¨å¾ªç¯å®ç°çš„å·ç§¯éå¸¸æ…¢ã€‚è€ŒçŸ©é˜µä¹˜æ³•æ˜¯ç°ä»£è®¡ç®—åº“ï¼ˆå¦‚ BLAS, LAPACKï¼ŒNumPy åº•å±‚å°±ä¾èµ–å®ƒä»¬ï¼‰ä¸­ä¼˜åŒ–å¾—æœ€å¥½çš„è¿ç®—ä¹‹ä¸€ã€‚é€šè¿‡å°†å·ç§¯è½¬æ¢ä¸ºä¸€ä¸ªå¤§çš„çŸ©é˜µä¹˜æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™äº›é«˜åº¦ä¼˜åŒ–çš„åº“ï¼Œæå¤§åœ°æå‡è®¡ç®—é€Ÿåº¦ã€‚
2.  **è§„æ•´æ€§**ï¼šå°†å·ç§¯é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªç»Ÿä¸€çš„çŸ©é˜µä¹˜æ³•é—®é¢˜ï¼Œä½¿å¾—ç¡¬ä»¶ï¼ˆå¦‚ GPUï¼‰å¯ä»¥æ›´é«˜æ•ˆåœ°å¹¶è¡Œå¤„ç†æ•°æ®ã€‚

`img2col` çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å°†è¾“å…¥å›¾ç‰‡ä¸­æ‰€æœ‰ä¸å·ç§¯æ ¸è¿›è¡Œè¿ç®—çš„å±€éƒ¨åŒºåŸŸï¼ˆpatchï¼‰æå–å‡ºæ¥ï¼Œå¹¶å°†æ¯ä¸ªåŒºåŸŸå±•å¼€æˆä¸€ä¸ªåˆ—å‘é‡ï¼Œæœ€åå°†æ‰€æœ‰åˆ—å‘é‡æ‹¼æ¥æˆä¸€ä¸ªå¤§çŸ©é˜µã€‚**

-----

### `img2col` çš„å·¥ä½œåŸç†

æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥ç†è§£è¿™ä¸ªè¿‡ç¨‹ã€‚

**å‡è®¾æˆ‘ä»¬æœ‰ï¼š**

  * **è¾“å…¥å›¾åƒ (Input Image)**ï¼šä¸€ä¸ª 4x4 çš„å•é€šé“å›¾åƒã€‚
  * **å·ç§¯æ ¸ (Kernel)**ï¼šä¸€ä¸ª 3x3 çš„å·ç§¯æ ¸ã€‚
  * **æ­¥å¹… (Stride)**ï¼š$S=1$
  * **å¡«å…… (Padding)**ï¼š$P=0$

**1. è®¡ç®—è¾“å‡ºå°ºå¯¸**

é¦–å…ˆï¼Œæ ¹æ®å·ç§¯å…¬å¼è®¡ç®—è¾“å‡ºå›¾åƒçš„å°ºå¯¸ï¼š
$W_{out} = \frac{(W_{in} - K_W + 2P)}{S} + 1 = \frac{(4 - 3 + 0)}{1} + 1 = 2$
$H_{out} = \frac{(H_{in} - K_H + 2P)}{S} + 1 = \frac{(4 - 3 + 0)}{1} + 1 = 2$
æ‰€ä»¥ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ª 2x2 çš„çŸ©é˜µã€‚è¿™æ„å‘³ç€å·ç§¯æ ¸ä¼šåœ¨è¾“å…¥å›¾åƒä¸Šæ»‘åŠ¨ 2x2 = 4 æ¬¡ã€‚

**2. æå–å±€éƒ¨åŒºåŸŸå¹¶å±•å¼€ (The `img2col` part)**

`img2col` ç®—æ³•ä¼šæ‰¾åˆ°è¿™ 4 ä¸ªä¸å·ç§¯æ ¸å¯¹åº”çš„å±€éƒ¨åŒºåŸŸï¼Œå¹¶å°†æ¯ä¸ª 3x3 çš„åŒºåŸŸâ€œæ‹‰ç›´â€æˆä¸€ä¸ª $3 \times 3 = 9$ ç»´çš„åˆ—å‘é‡ã€‚

*å›¾ç‰‡æ¥æºï¼šStanford CS231n è¯¾ç¨‹ç¬”è®°*

  * **ç¬¬1ä¸ªä½ç½® (å·¦ä¸Šè§’)**ï¼šæå–å›¾åƒä¸­ `[0:3, 0:3]` çš„åŒºåŸŸï¼Œå±•å¼€æˆç¬¬1åˆ—ã€‚
  * **ç¬¬2ä¸ªä½ç½® (å³ä¸Šè§’)**ï¼šæå–å›¾åƒä¸­ `[0:3, 1:4]` çš„åŒºåŸŸï¼Œå±•å¼€æˆç¬¬2åˆ—ã€‚
  * **ç¬¬3ä¸ªä½ç½® (å·¦ä¸‹è§’)**ï¼šæå–å›¾åƒä¸­ `[1:4, 0:3]` çš„åŒºåŸŸï¼Œå±•å¼€æˆç¬¬3åˆ—ã€‚
  * **ç¬¬4ä¸ªä½ç½® (å³ä¸‹è§’)**ï¼šæå–å›¾åƒä¸­ `[1:4, 1:4]` çš„åŒºåŸŸï¼Œå±•å¼€æˆç¬¬4åˆ—ã€‚

æœ€ç»ˆï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ª $9 \times 4$ çš„çŸ©é˜µï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º `col_matrix`ã€‚æ¯ä¸€åˆ—ä»£è¡¨ä¸€ä¸ªæ„Ÿå—é‡ï¼ˆreceptive fieldï¼‰ï¼Œæ€»å…±æœ‰ 4 åˆ—ï¼Œå¯¹åº” 4 ä¸ªè¾“å‡ºç‚¹ã€‚

**3. è½¬æ¢å·ç§¯æ ¸**

å·ç§¯æ ¸ä¹Ÿéœ€è¦è¢«è½¬æ¢ã€‚æˆ‘ä»¬å°† 3x3 çš„å·ç§¯æ ¸çŸ©é˜µåŒæ ·â€œæ‹‰ç›´â€æˆä¸€ä¸ª $1 \times 9$ çš„è¡Œå‘é‡ã€‚
å¦‚æœæœ‰ $N$ ä¸ªå·ç§¯æ ¸ï¼Œæˆ‘ä»¬å°±å°†å®ƒä»¬å…¨éƒ¨æ‹‰ç›´ï¼Œå¹¶å †å æˆä¸€ä¸ª $N \times 9$ çš„çŸ©é˜µï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º `kernel_matrix`ã€‚

**4. æ‰§è¡ŒçŸ©é˜µä¹˜æ³•**

ç°åœ¨ï¼Œå·ç§¯è¿ç®—å°±å˜æˆäº† `kernel_matrix` å’Œ `col_matrix` çš„çŸ©é˜µä¹˜æ³•ï¼š

`Result = kernel_matrix @ col_matrix`

  * `kernel_matrix` çš„ç»´åº¦: $(N, K_H \times K_W \times C_{in})$  (è¿™é‡Œæ˜¯ $(1, 9)$)
  * `col_matrix` çš„ç»´åº¦: $(K_H \times K_W \times C_{in}, H_{out} \times W_{out})$ (è¿™é‡Œæ˜¯ $(9, 4)$)
  * `Result` çš„ç»´åº¦: $(N, H_{out} \times W_{out})$ (è¿™é‡Œæ˜¯ $(1, 4)$)

**5. è½¬æ¢å›è¾“å‡ºæ ¼å¼**

æœ€åï¼Œå°†å¾—åˆ°çš„ $1 \times 4$ çš„ç»“æœçŸ©é˜µ `Result` é‡æ–°å¡‘å½¢ï¼ˆreshapeï¼‰æˆæˆ‘ä»¬æœŸæœ›çš„è¾“å‡ºå›¾åƒå°ºå¯¸ $(N, H_{out}, W_{out})$ï¼Œä¹Ÿå°±æ˜¯ $(1, 2, 2)$ã€‚

è¿™æ ·ï¼Œä¸€æ¬¡å¤æ‚çš„å·ç§¯è¿ç®—å°±å®Œå…¨è¢«ä¸€æ¬¡é«˜æ•ˆçš„çŸ©é˜µä¹˜æ³•æ›¿ä»£äº†ã€‚

-----

### Python (NumPy) å®ç°

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ `img2col` å’Œå·ç§¯è½¬æ¢çš„å®ç°ã€‚ä¸ºäº†æ¸…æ™°åœ°å±•ç¤ºç®—æ³•æœ¬èº«ï¼Œæˆ‘ä»¬å…ˆç”¨å¾ªç¯æ¥å®ç° `img2col`ï¼Œè¿™èƒ½è®©ä½ æ›´å¥½åœ°ç†è§£å…¶å·¥ä½œåŸç†ã€‚

```python
import numpy as np

def get_output_dims(input_height, input_width, kernel_height, kernel_width, stride, padding):
    """è®¡ç®—å·ç§¯æ“ä½œçš„è¾“å‡ºç»´åº¦"""
    output_height = (input_height - kernel_height + 2 * padding) // stride + 1
    output_width = (input_width - kernel_width + 2 * padding) // stride + 1
    return output_height, output_width

def img2col(input_data, kernel_height, kernel_width, stride=1, padding=0):
    """
    å°†è¾“å…¥å›¾åƒ/ç‰¹å¾å›¾è½¬æ¢ä¸ºåˆ—çŸ©é˜µã€‚
    
    å‚æ•°:
    - input_data: è¾“å…¥æ•°æ®ï¼Œå½¢çŠ¶ä¸º (N, C, H, W)ï¼ŒN=æ‰¹å¤§å°, C=é€šé“æ•°
    - kernel_height: å·ç§¯æ ¸é«˜åº¦
    - kernel_width: å·ç§¯æ ¸å®½åº¦
    - stride: æ­¥å¹…
    - padding: å¡«å……
    
    è¿”å›:
    - cols: è½¬æ¢åçš„åˆ—çŸ©é˜µ
    """
    N, C, H, W = input_data.shape
    
    # è®¡ç®—è¾“å‡ºç»´åº¦
    out_h, out_w = get_output_dims(H, W, kernel_height, kernel_width, stride, padding)
    
    # å¯¹è¾“å…¥æ•°æ®è¿›è¡Œå¡«å……
    # np.padçš„æ ¼å¼æ˜¯((axis0_pad), (axis1_pad), ...)ï¼Œè¿™é‡Œæˆ‘ä»¬åªå¡«å……Hå’ŒWç»´åº¦
    img = np.pad(input_data, [(0,0), (0,0), (padding, padding), (padding, padding)], 'constant')
    
    # åˆå§‹åŒ–è¾“å‡ºçŸ©é˜µ
    # æ¯ä¸€åˆ—æ˜¯ä¸€ä¸ªæ‹‰ç›´çš„æ„Ÿå—é‡ï¼Œæ€»å…±æœ‰ out_h * out_w åˆ—
    # æ¯ä¸€è¡Œæ˜¯æ„Ÿå—é‡ä¸­çš„ä¸€ä¸ªåƒç´ ï¼Œæ€»å…±æœ‰ C * kernel_height * kernel_width è¡Œ
    cols = np.zeros((C * kernel_height * kernel_width, N * out_h * out_w))
    
    # æ ¸å¿ƒè½¬æ¢é€»è¾‘ï¼ˆä½¿ç”¨å¾ªç¯ï¼Œä¾¿äºç†è§£ï¼‰
    for y in range(out_h):
        y_start = y * stride
        for x in range(out_w):
            x_start = x * stride
            
            # ä»å¡«å……åçš„å›¾åƒä¸­æå–å½“å‰çª—å£çš„ patch
            # patch çš„å½¢çŠ¶æ˜¯ (N, C, kernel_height, kernel_width)
            patch = img[:, :, y_start:y_start+kernel_height, x_start:x_start+kernel_width]
            
            # å°† patch æ‹‰ç›´æˆåˆ—å‘é‡ï¼Œå¹¶æ”¾å…¥ cols çŸ©é˜µçš„å¯¹åº”ä½ç½®
            # æ‹‰ç›´åçš„å½¢çŠ¶æ˜¯ (N, C*kernel_height*kernel_width)
            # æˆ‘ä»¬éœ€è¦æŠŠå®ƒå˜æˆ (C*kernel_height*kernel_width, N) å†æ”¾å…¥
            # (y * out_w + x) æ˜¯å½“å‰ patch å¯¹åº”çš„è¾“å‡ºä½ç½®çš„ç´¢å¼•
            # N * (y * out_w + x) æ˜¯è€ƒè™‘åˆ°æ‰¹æ¬¡å¤§å°çš„åˆ—èµ·å§‹ç´¢å¼•
            col_index_start = N * (y * out_w + x)
            cols[:, col_index_start:col_index_start+N] = patch.reshape(N, -1).T
            
    return cols

def conv_forward_gemm(x, w, b, stride=1, padding=0):
    """
    ä½¿ç”¨ img2col å’ŒçŸ©é˜µä¹˜æ³•å®ç°å·ç§¯å‰å‘ä¼ æ’­ã€‚
    
    å‚æ•°:
    - x: è¾“å…¥æ•°æ®, å½¢çŠ¶ (N, C, H, W)
    - w: å·ç§¯æ ¸æƒé‡, å½¢çŠ¶ (F, C, kH, kW) (Fæ˜¯å·ç§¯æ ¸æ•°é‡)
    - b: åç½®, å½¢çŠ¶ (F,)
    - stride: æ­¥å¹…
    - padding: å¡«å……
    
    è¿”å›:
    - out: å·ç§¯æ“ä½œçš„è¾“å‡º
    """
    N, C, H, W = x.shape
    F, _, kH, kW = w.shape
    
    # 1. å°†è¾“å…¥å›¾åƒ x é€šè¿‡ img2col è½¬æ¢
    cols = img2col(x, kH, kW, stride, padding)
    
    # 2. å°†å·ç§¯æ ¸ w æ‹‰ç›´æˆè¡Œå‘é‡
    # w çš„å½¢çŠ¶æ˜¯ (F, C, kH, kW)ï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒå˜æˆ (F, C*kH*kW)
    kernels_reshaped = w.reshape(F, -1)
    
    # 3. æ‰§è¡ŒçŸ©é˜µä¹˜æ³•
    # (F, C*kH*kW) @ (C*kH*kW, N*out_h*out_w) -> (F, N*out_h*out_w)
    out = kernels_reshaped @ cols
    
    # 4. åŠ ä¸Šåç½®é¡¹
    # b çš„å½¢çŠ¶æ˜¯ (F,)ï¼Œéœ€è¦ reshape æˆ (F, 1) ä»¥åˆ©ç”¨å¹¿æ’­æœºåˆ¶
    out += b.reshape(-1, 1)
    
    # 5. å°†ç»“æœ reshape å›æ ‡å‡†çš„è¾“å‡ºæ ¼å¼
    out_h, out_w = get_output_dims(H, W, kH, kW, stride, padding)
    # é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å°†æ‰¹æ¬¡ç»´åº¦NæŒªåˆ°å‰é¢
    # å½“å‰ out å½¢çŠ¶æ˜¯ (F, N*out_h*out_w)ï¼Œå…ˆ reshape æˆ (F, N, out_h, out_w)
    out = out.reshape(F, N, out_h, out_w)
    # ç„¶åäº¤æ¢ F å’Œ N ç»´åº¦ï¼Œå¾—åˆ° (N, F, out_h, out_w)
    out = out.transpose(1, 0, 2, 3)
    
    return out

# --- ç¤ºä¾‹ ---
if __name__ == '__main__':
    # è®¾ç½®éšæœºç§å­ä»¥ä¿è¯ç»“æœå¯å¤ç°
    np.random.seed(0)

    # å®šä¹‰è¾“å…¥å‚æ•°
    N = 2      # æ‰¹å¤§å°
    C = 3      # è¾“å…¥é€šé“æ•°
    H = 8      # è¾“å…¥é«˜åº¦
    W = 8      # è¾“å…¥å®½åº¦
    
    F = 4      # å·ç§¯æ ¸æ•°é‡ (è¾“å‡ºé€šé“æ•°)
    kH = 3     # å·ç§¯æ ¸é«˜åº¦
    kW = 3     # å·ç§¯æ ¸å®½åº¦
    
    stride = 1
    padding = 1

    # åˆ›å»ºéšæœºè¾“å…¥æ•°æ®å’Œå·ç§¯æ ¸/åç½®
    input_data = np.random.randn(N, C, H, W)
    kernels = np.random.randn(F, C, kH, kW)
    bias = np.random.randn(F)

    # ä½¿ç”¨æˆ‘ä»¬çš„å‡½æ•°è®¡ç®—å·ç§¯
    output_gemm = conv_forward_gemm(input_data, kernels, bias, stride, padding)

    print("è¾“å…¥æ•°æ®å½¢çŠ¶:", input_data.shape)
    print("å·ç§¯æ ¸å½¢çŠ¶:", kernels.shape)
    print("è¾“å‡ºæ•°æ®å½¢çŠ¶:", output_gemm.shape)
    
    # éªŒè¯è¾“å‡ºå°ºå¯¸æ˜¯å¦æ­£ç¡®
    expected_out_h, expected_out_w = get_output_dims(H, W, kH, kW, stride, padding)
    print(f"é¢„æœŸè¾“å‡ºå°ºå¯¸: ({expected_out_h}, {expected_out_w})")
    assert output_gemm.shape == (N, F, expected_out_h, expected_out_w)
    
    # (å¯é€‰) ä¸ä¸€ä¸ªç®€å•çš„å¾ªç¯å·ç§¯å®ç°è¿›è¡Œå¯¹æ¯”ï¼ŒéªŒè¯æ•°å€¼æ­£ç¡®æ€§
    # æ³¨æ„ï¼šä¸‹é¢çš„æœ´ç´ å®ç°éå¸¸æ…¢ï¼Œä»…ç”¨äºéªŒè¯
    def naive_conv(x, w, b, stride, padding):
        N, C, H, W = x.shape
        F, _, kH, kW = w.shape
        out_h, out_w = get_output_dims(H, W, kH, kW, stride, padding)
        x_padded = np.pad(x, [(0,0), (0,0), (padding, padding), (padding, padding)], 'constant')
        out = np.zeros((N, F, out_h, out_w))
        
        for n in range(N):
            for f in range(F):
                for y in range(out_h):
                    for x in range(out_w):
                        y_start = y * stride
                        x_start = x * stride
                        patch = x_padded[n, :, y_start:y_start+kH, x_start:x_start+kW]
                        out[n, f, y, x] = np.sum(patch * w[f]) + b[f]
        return out
        
    output_naive = naive_conv(input_data, kernels, bias, stride, padding)
    
    print("\nä¸¤ç§æ–¹æ³•ç»“æœæ˜¯å¦æ¥è¿‘:", np.allclose(output_gemm, output_naive))

```

### ä¼˜ç¼ºç‚¹æ€»ç»“

**ä¼˜ç‚¹:**

  * **æ€§èƒ½**ï¼šå¦‚å‰æ‰€è¿°ï¼Œå°†é—®é¢˜è½¬æ¢ä¸ºå¤§å‹çŸ©é˜µä¹˜æ³•å¯ä»¥åˆ©ç”¨é«˜åº¦ä¼˜åŒ–çš„æ•°å€¼åº“ï¼Œé€Ÿåº¦è¿œå¿«äºæœ´ç´ çš„å¾ªç¯å®ç°ã€‚è¿™æ˜¯æ·±åº¦å­¦ä¹ æ¡†æ¶ï¼ˆå¦‚ PyTorch, TensorFlowï¼‰åœ¨åº•å±‚å®ç°å·ç§¯çš„æ ¸å¿ƒæŠ€æœ¯ä¹‹ä¸€ã€‚

**ç¼ºç‚¹:**

  * **å†…å­˜æ¶ˆè€—**ï¼š`img2col` ç®—æ³•éœ€è¦åˆ›å»ºä¸€ä¸ªä¸­é—´çŸ©é˜µ `cols`ã€‚è¿™ä¸ªçŸ©é˜µå¯èƒ½éå¸¸å¤§ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªè¾“å…¥ä¸º `(1, 256, 14, 14)`ï¼Œå·ç§¯æ ¸ä¸º `3x3` çš„æƒ…å†µï¼Œ`cols` çŸ©é˜µçš„å½¢çŠ¶å°†æ˜¯ `(256*3*3, 14*14) = (2304, 196)`ï¼Œè¿™è¿˜ç®—å¯æ§ã€‚ä½†å¦‚æœè¾“å…¥å›¾åƒå¾ˆå¤§ï¼Œè¿™ä¸ªçŸ©é˜µä¼šå ç”¨å·¨å¤§çš„å†…å­˜ç©ºé—´ã€‚å› ä¸ºåŒä¸€ä¸ªåƒç´ ç‚¹å¯èƒ½ä¼šåœ¨ä¸åŒçš„å±€éƒ¨åŒºåŸŸï¼ˆpatchï¼‰ä¸­é‡å¤å‡ºç°ï¼Œå¯¼è‡´æ•°æ®å†—ä½™å­˜å‚¨ã€‚

ç”±äºå†…å­˜æ¶ˆè€—çš„é—®é¢˜ï¼Œåç»­ä¹Ÿå‘å±•å‡ºäº†å¦‚ Winogradã€FFT ç­‰å…¶ä»–é«˜æ•ˆçš„å·ç§¯ç®—æ³•ï¼Œå®ƒä»¬åœ¨ä¸åŒåœºæ™¯ä¸‹ï¼ˆå¦‚å°å·ç§¯æ ¸ vs å¤§å·ç§¯æ ¸ï¼‰å„æœ‰ä¼˜åŠ¿ã€‚ä½† `im2col` + GEMM çš„æ–¹æ³•å› å…¶é€šç”¨æ€§å’Œé«˜æ•ˆæ€§ï¼Œä»ç„¶æ˜¯å®ç°å·ç§¯è¿ç®—çš„åŸºçŸ³ã€‚