# 稳定快速排序的实现方法

### 🧑‍💻 User

众所周知，快速排序是不稳定的，那如何修改让它稳定呢？

---

### 🤖 Assistant

好的，这是一个非常经典的数据结构与算法问题。我们都知道快速排序（Quicksort）的平均时间复杂度为 $O(n \log n)$，且是原地排序（空间复杂度 $O(\log n)$），性能非常出色，但它的主要缺点之一就是**不稳定性**。

首先，我们来回顾一下为什么标准的快速排序是不稳定的。

### 为什么快速排序不稳定？

不稳定的根源在于它的**分区（Partition）**操作。以经典的Lomuto或Hoare分区方案为例，它们在交换元素时，可能会将两个相等元素的原始相对顺序打乱。

举个简单的例子，假设我们对数组 `[3, 5A, 1, 5B, 4]` 进行排序，其中 `5A` 和 `5B` 的值相等，但我们希望能保持它们原有的 `A` 在 `B` 前的顺序。

如果我们选择 `3` 作为基准（pivot）：
1. 分区操作开始，一个指针 `i` 从左边开始，一个指针 `j` 从右边开始。
2. 指针 `j` 向左移动，遇到 `4` (大于 `3`)，继续；遇到 `5B` (大于 `3`)，继续；遇到 `1` (小于 `3`)，停止。
3. 指针 `i` 向右移动，遇到 `5A` (大于 `3`)，停止。
4. 此时，`i` 和 `j` 指向的元素 `5A` 和 `1` 需要交换。数组变为 `[3, 1, 5A, 5B, 4]`。
5. 在这个交换过程中，`5A` 和 `5B` 的相对顺序没有改变。

但如果我们选择 `4` 作为基准：
1. `j` 指针从右向左，遇到 `5B` (大于 `4`)，停止。
2. `i` 指针从左向右，遇到 `3` (小于 `4`)，继续；遇到 `5A` (大于 `4`)，停止。
3. 交换 `i` 和 `j` 指向的元素 `5A` 和 `5B`。数组变为 `[3, 5B, 1, 5A, 4]`。
4. **此时，`5B` 被换到了 `5A` 的前面，它们的原始相对顺序被破坏了。** 因此，快速排序是不稳定的。

---

### 如何修改让快速排序变得稳定？

要使快速排序稳定，核心思想是**在分区操作中避免打乱相等元素的相对顺序**。主要有以下几种方法：

#### 方法一：使用额外空间（最直接的方法）

这是一种空间换时间的思路，通过使用辅助空间来保证稳定性。

1.  **三路切分（3-Way Partitioning）**：
    在分区时，不再是将数组分为 `(< pivot)` 和 `(>= pivot)` 两部分，而是分为三部分：
    * 严格小于 pivot 的元素
    * 等于 pivot 的元素
    * 严格大于 pivot 的元素

2.  **具体实现**：
    * 创建三个临时的辅助列表（或队列）：`less`, `equal`, `greater`。
    * 遍历原始数组（或当前子数组），对于每个元素：
        * 如果它小于 pivot，就放入 `less` 列表。
        * 如果它等于 pivot，就放入 `equal` 列表。
        * 如果它大于 pivot，就放入 `greater` 列表。
    * 由于我们是按原始顺序遍历并添加到列表末尾的，所以 `less`, `equal`, `greater` 内部的元素都保持了其原始的相对顺序。
    * 将这三个列表按 `less` -> `equal` -> `greater` 的顺序拼接起来，放回原数组。
    * 递归地对 `less` 和 `greater` 部分进行快速排序（`equal` 部分已经有序，无需处理）。

**优点**：
* 逻辑清晰，实现简单。
* 绝对能保证稳定性。

**缺点**：
* 需要 $O(n)$ 的额外空间来存放三个临时列表，违背了快速排序“原地排序”的初衷。

#### 方法二：记录元素的原始索引（改变比较逻辑）

这是一种不改变排序算法本身，而是改变数据结构和比较方式的技巧。

1.  **数据封装**：将原始数组中的每个元素封装成一个对象或元组（tuple），例如 `(value, original_index)`。
    * 对于数组 `[3, 5A, 1, 5B]`，我们可以转换成 `[(3, 0), (5, 1), (1, 2), (5, 3)]`。

2.  **修改比较函数**：
    在快速排序的比较逻辑中，我们进行如下修改：
    * 首先比较 `value`。
    * 如果 `value` 不相等，则按 `value` 的大小决定顺序。
    * 如果 `value` 相等，则比较它们的 `original_index`，索引小的排在前面。

3.  **执行排序**：
    使用这个新的比较规则来执行标准的快速排序。当两个 `5` 相遇时，因为 `(5, 1)` 的索引 `1` 小于 `(5, 3)` 的索引 `3`，所以 `(5, 1)` 永远会被认为“小于”`(5, 3)`，因此它们的相对位置永远不会被调换。

**优点**：
* 可以继续使用任何标准的快速排序实现，只需提供一个自定义的比较器即可。
* 保证了稳定性。

**缺点**：
* 需要 $O(n)$ 的额外空间来存储原始索引，同样失去了原地排序的优势。
* 增加了比较的开销。

#### 方法三：修改原地分区算法（最复杂的方法）

这是技术上最复杂但最接近“原地稳定快排”理想的方案。目标是在不使用 $O(n)$ 额外空间的前提下，实现稳定的分区。

这种方法非常精巧且不常见。一个思路是，在分区时，将小于 pivot 的元素移动到左边，而等于或大于 pivot 的元素则留在右边，但是移动过程要像“插入排序”那样，一个一个地向后挪动元素，而不是通过简单的交换。

例如，对于 `[...A...B...]`，当 `A` 小于 pivot 需要移动到前面时，不是和某个元素交换，而是将 `A` 前面的元素整体向后移动一位，为 `A` 腾出空间。这个过程可以保证不打乱 `A` 右侧元素的相对顺序。

**优点**：
* 可以实现近乎原地（$O(\log n)$ 空间）的稳定快速排序。

**缺点**：
* 实现非常复杂，很容易出错。
* 元素移动的成本很高，会导致算法的时间复杂度常数变得很大，实际性能可能不如使用额外空间的方法，甚至不如稳定的归并排序。

---

### 总结与权衡

| 方法 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **方法一：额外空间三路切分** | 逻辑简单，保证稳定 | $O(n)$ 额外空间，非原地 | 对空间不敏感，追求实现简单和稳定性的场合。 |
| **方法二：记录原始索引** | 不改动快排核心，保证稳定 | $O(n)$ 额外空间，比较开销增大 | 当排序对象是复杂结构，且可以方便地附加额外信息时。 |
| **方法三：修改原地分区算法** | 空间复杂度低 $O(\log n)$ | 实现极为复杂，时间常数大 | 理论研究或对空间有极端要求的特殊场景。 |

**结论**：
虽然理论上可以通过复杂的方式实现稳定的原地快速排序，但在实际工程中，当需要一个**稳定**且**高效**的排序算法时，人们通常会选择**归并排序（Merge Sort）**或**Timsort**（Python 和 Java 中 `sort` 的实现）。

* **归并排序**：天然稳定，且时间复杂度稳定在 $O(n \log n)$。它的主要缺点是需要 $O(n)$ 的额外空间。
* **Timsort**：归并排序和插入排序的混合体，在实际数据中表现极好，并且是稳定的。

因此，将快速排序修改为稳定版本，更多的是一个有趣的算法练习。在生产环境中，如果稳定性是硬性要求，直接选择一个天然稳定的优秀算法通常是更明智、更安全的选择。