# 在 Unity 脚本中使用函数

> [Unity 官方教程 - 函数简介](https://learn.unity.com/tutorial/han-shu-jian-jie?uv=2020.3&projectId=5fad021eedbc2a00225e688f)  
> [C# 官方教程 - 方法](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/methods)

## 1. 函数概念

function - 函数 等同于 C# 中的概念 method - 方法

背景：以前在非面向对象程序设计时候是面向过程进行编程的，程序代码是由语句+函数块组成的，没有类和对象的结构，那个时候我们将会重复用到的语句块，起名叫函数，并可以重复调用他，后面到了面向对象程序设计中，类似的概念被叫做方法，他们的概念与编写方式也是类似的。

作用：是包含一系列语句的代码块。可以把常用功能，写在一个函数中，方便重复使用，避免我们编写大量冗余代码。

对于函数的使用者来说，函数就是一个抽象的过程，你可以理解成一个执行特定功能的黑盒子，只需要知道他的使用方式，就可以很方便的执行需要的操作，有点类似于一个封装的思想。

- 函数的定义：函数体代码的书写，构建一个函数
- 函数的调用：通过函数名，调用并执行函数中所包含的语句的过程
  
规则：  
定义格式： 访问级别 返回值类型 方法名(形式参数列表){ 函数体语句段... }

调用格式： 对象名或类名.函数名(实际参数列表)
  
我们不妨以函数的思想优化下前面写的代码，以我们之前写的 PotionSpawner 组件脚本为例，我们研究下这个生成对象的方法—— Object.Instantiate，从start函数开始的22-35行，他们的目的是在指定的位置和角度生成一个新的游戏对象，生成对象的类型是由 ObjectToSpawn 字段传递的，它要绑定一个gameObject，新的位置 spawnPosition 是由原来的位置坐标 + 一个方向 * 距离计算出新的位置 传递，Quaternion.identity是物体的旋转角度。
  
可以看到，后面类似功能的代码段重复了3次，那我们可以试着把上面这段代码提取出来，制作成一个函数来重复的去调用他。
  
我们思考下如何构建这个函数，首先，我们这个函数的功能是在指定的角度和方位生成新的游戏对象，然后是给我们的函数命名，如：GenerateNewObject，然后我们函数这个黑盒子也应该有相应的功能，需要传递输入值（angle），做什么事（实例化游戏对象），是否要求返回值（我们这里没有，所以为空，void）...
  
注意看我新创建的这个GerNewObject函数，他的前面有一个 private 的访问修饰符，如果为Public字段，表示可以在inspector里面被访问到，也可以被修改和赋值，由于这个函数仅供当前的类使用，所以不需要暴露出去，就用private修饰，增加类的安全性，如果不加private直接用void则默认作为private void处理，在c#中，函数名，类名应尽量使用Pascal规则命名，即首字母要大写。

而GerNewObject函数后面跟着括号里面的变量是要传入的参数，这个叫形式参数，即数据的入口，这里的参数可以说0个或多个，这里为了让不同的物体角度不一样，这里我们要给与不同的angle

  
既然我们已经定义了函数，最后就是在Start方法里面无脑调用我们的函数了，调用方式就是函数名称+实际参数 即可，实际参数是调用函数时候用的，形式参数是创建函数时候用到的，代码执行的时候会把实际参数的值传递给形式参数，我们调用函数加的参数和自定义方法的传入参数也是一一对应的，即Spawnangle1的值会被存放进angle里面，可以看到，代码相较于之前精简了不少，效果也是一样的

```C#
public int  Add(int x, int y ,int z)
{
   return x+y+z;
}

int num = Add(1,2,3);

int a,b,c;
a =5;
b=3;
c=6;
int x = Add(a,b,3+c);

```

### 1.1 函数头（方法签名）

函数体前面的部分，可以包含访问级别（如 public 或 private）、可选修饰符（如 abstract 或 sealed）、返回值、方法的名称以及任何方法参数。

### 1.2 参数

用来定义、获取传递给函数的输入值的变量(或对象)

- 形式参数（形参）: 定义函数时，用来声明类型和占位用的参数

- 实际参数（实参）: 调用函数时，存储实际数值，为函数传递输入值的参数

### 1.3 函数体

{} 中包含的内容

## 2. 使用函数

### 2.1 函数的创建和调用

将生成药水的重复代码，转换为函数

- 步骤 1：观察重复（或者类似）的代码
  - 参数和返回值：判断这段代码的输入输出，输入的值设置为参数；根据输出值类型，设定返回值类型
  - 函数名：根据代码段功能，起一个合适的函数名
- 步骤 2 ：书写函数
- 步骤 3 ： 测试函数，如果有问题则更改，循环这个过程，到你满意为止

```C#
//引入命名空间 UnityEngine
using UnityEngine;

// 生成器示例类
// 这个生成器会在不同位置，生成三个指定的游戏对象
public class SpawnerSample : MonoBehaviour
{
    // 声明 一个attribute（字段），是一个游戏对象，用来获取生成器生成的 gameobject
    public GameObject ObjectToSpawn;
    // 声明一个变量，用来存放距离
    public int radius;
    // start事件方法，是包含此脚本的游戏对象 Start is called just before any of the Update methods is called the first time
    // 在 update 前执行，且在游戏对象生命周期只执行一次
    // Start is only called once in the lifetime of the behaviour.
    void Start()
    {

        // 调用 函数
        GerNewObject(15);

        GerNewObject(35);

        GerNewObject(55);

        GerNewObject(75);

        GerNewObject(95);

        GerNewObject(115);

        GerNewObject(135);

        GerNewObject(155);
    }

    // 自定义函数，用来在指定角度生成新对象
    private void GerNewObject(int angle) {
        // 根据 angel 计算出一个方向
        Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.right;
        // 根据当前游戏对象所在位置，结合方向 direction、距离 radius，计算出一个新的位置，作为新对象的生成点位
        Vector3 spawnPosition = transform.position + direction * radius;
        // 生成指定对象
        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);
    }
}


```

```C#
using CreatorKitCode;
//引入命名空间 UnityEngine
using UnityEngine;

// 生成器示例类
// 这个生成器会在不同位置，生成三个指定的游戏对象
public class SpawnerSample : MonoBehaviour
{
    // 声明 一个attribute（字段），是一个游戏对象，用来获取生成器生成的 gameobject
    public GameObject ObjectToSpawn;
    // 声明一个变量，用来存放距离
    public float radius;
    public int Spawnangle1 = 15;
    public int Spawnangle2 = 55;
    public int Spawnangle3 = 95;
    public int Spawnangle4 = 135;
    // start事件方法，是包含此脚本的游戏对象 Start is called just before any of the Update methods is called the first time
    // 在 update 前执行，且在游戏对象生命周期只执行一次
    // Start is only called once in the lifetime of the behaviour.
    void Start()
    {
        // 调用 函数
        GerNewObject(Spawnangle1);

        GerNewObject(Spawnangle2);

        GerNewObject(Spawnangle3);

        GerNewObject(Spawnangle4);
    }
    // 自定义函数，用来在指定角度生成新对象
    private void GerNewObject(int angle)
    {
        // 根据 angel 计算出一个方向
        Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.right;
        // 根据当前游戏对象所在位置，结合方向 direction、距离 radius，计算出一个新的位置，作为新对象的生成点位
        Vector3 spawnPosition = transform.position + direction * radius;
        // 生成指定对象
        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);
    }
}


```

### 2.2 函数调试

- 用 Console 查看错误提示和警告
- 用 vs 2019 进行 debug

配套视频教程：
[https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912](https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912)

文章也同时同步微信公众号，喜欢使用手机观看文章的可以关注

![](../../imgs/微信公众号二维码.jpg)
