# 封装和继承
  
复习：如何理解组件类和对象：比如说我们在这个游戏对象挂载的这个脚本组件，它实际上就是一个定义好的类，但是实际使用时候会被unity将这个类实例化成一个对象，所以真正在游戏里面使用的是这个对象而不是类，类本身只是一个模板，这个实例化的过程在unity的编译器内完成了。
  
比如说SpawnerSample组件，这个类可以生成血瓶，也能生成其他的游戏对象，比如我们新建一个游戏对象，然后为这个对象挂载一个SpawnerSample的组件，然后这个游戏对象就有了生成新游戏对象的功能了，说明这个类又能创建新的对象，只是这个对象作为组件又被加到另外一个游戏对象（Sphere）上。
  
为ObjectToSpawn绑定游戏对象，比如MoneyLoot，这样我们这个组件就具有了生成money的功能。所以说白了就是我们用一个模板创建一个类之后，就可以多次使用它来继续创建同种类型（gameObject）的不同对象。至此，我们就讲完了类与对象之间的关系以及在unity里面的体现：组件也是类，组件类可以继续生成组件和对象，组件决定游戏对象具有哪些功能。
  
## 1. 封装

概念：封装，说白了就是保护敏感数据，防止不具备权限者，随意更改特定数据的方法

封装 被定义为"把一个或多个项目封闭在一个物理的或者逻辑的包中"。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。

### 1.1 访问限制修饰关键字
  
要实现封装，必然要用到访问限制修饰关键字（访问修饰符），它能有助于提高数据安全性
  
以下是常见的访问修饰符：
  
- public：任何位置都可以访问；
- private：只有在自己的类体中可以访问，比如说在类体中定义的变量，函数，如果没有加访问修饰符，c#默认视为private（私有的）；
- protected：只有该类对象及其子类对象可以访问
- internal：同一个程序集(同一项目)的对象可以访问；
- protected internal：访问限于当前程序集或派生自包含类的类型。

> C# 默认访问修饰符：
>
> - 如果没有显示的给这些元素(类、接口、结构、枚举等)访问修饰符，其修饰符默认为 internal
> - 类中所有的成员，默认均为 private
> - 接口的成员默认访问修饰符是 public
> - 命名空间，枚举类型成员默认 public
  
### 1.2 在 unity 中的体现

public 变量 可以在 Inspector 中直接操作，其他的不行，找不到这些变量
  
还是用这段代码，回顾上面用到的知识点：
  
【百日挑战34】unity教程之学习脚本编程初步（十七）
  
前言：在上期教程中，我们复习了类与对象之间的关系以及在unity里面的体现，开始学习c#面向对象的三大特性之二——封装与继承，了解了封装的概念，重点讲解了访问限制修饰关键字，今天让我们来继续学习c#继承和派生的有关内容。
  
## 2. 继承和派生

- 继承是指子类从父类继承所有非私有的属性和方法；主语是子类
- 派生指从父类派生出多个子类，主语是父类

```C#
<访问修饰符符> class <基类>
{
 ...
}
<访问修饰符符> class <派生类> : <基类>
{
 ...
}
```

继承：指的是，子类可以直接拥有父类中非私有的成员，包括数据和方法

继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。

当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的基类，这个新的类被称为派生类。

继承的思想实现了 属于（IS-A） 关系。例如，哺乳动物 属于（IS-A） 动物，狗 属于（IS-A） 哺乳动物，因此狗 属于（IS-A） 动物。

> 注意：
>
> 1. C# 中，所有类都派生自 Object ，即使这个自定义的类没有指定任何基类，C# 也会将 Object 做为它的基类
> 2. C# 中，任何类只能有一个基类
> 3. C# 中，子类代码里，使用 base 关键字指代基类
> 4. 构造方法较为特殊，有自己的名字，注意不能直接继承自父类，需要重写

```C#
//父类 Monster.cs
using System;
[Serializable]
public class Monster
{
    // 名字
    public string name;
    // 年龄
    public int age;
    // 毛色
    public string color;
    // 生命
    public int hp;

    public Monster() { }
    public Monster(string name, int age, string color, int hp)
    {
        this.name = name;
        this.age = age;
        this.color = color;
        this.hp = hp;
    }
}

// 派生类 Phoenix.cs
using System;
[Serializable]
public class Phoenix:Monster
{
    private bool isReborn=false;

    // 全参构造函数
    public Phoenix(string name, int age, string color, int hp,bool isReborn) : base(name, age, color, hp)
    {
        this.isReborn = isReborn;
    }
    //无参空构造方法
    public Phoenix()
    {
    }

    void Reborn() {
        this.hp = 1000;
        this.isReborn = true;
    }
}

```

## 3. 学习使用 Unity 或 C# 中的类

通过类名查 API 文档，比如 MonoBehaviour

MonoBehaviour 是一个基类，所有 Unity 脚本都派生自该类

> 参考资料：[https://www.runoob.com/csharp/](https://www.runoob.com/csharp/)

<br>

<hr>

> 作业：
> 查 Unity api 文档，预习 UnityEngine.MonoBehaviour

<br>

<hr>
<br>

配套视频教程：
[https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912](https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912)

文章也同时同步微信公众号，喜欢使用手机观看文章的可以关注

![](../../imgs/微信公众号二维码.jpg)
