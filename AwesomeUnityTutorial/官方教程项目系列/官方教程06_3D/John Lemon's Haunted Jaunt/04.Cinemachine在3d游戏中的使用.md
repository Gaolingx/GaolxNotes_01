# 【百日挑战84】Cinemachine 在游戏中的使用
  
前言：众所周知，在游戏开发中，相机是一个很重要的组件，屏幕能显示的区域是由游戏摄像机（Camera）控制的，它可以展示玩家所在的区域，并呈现在屏幕上，渲染游戏的Sprite、Model、VFX、HUD等等，Cinemachine 使你可以创建复杂的 3D 摄像机设置，从而允许在多个摄像机之间移动和切换。
  
## 1. 概念
  
Cinemachine 是一套用于操作 Unity 摄像机的模块。Cinemachine 解决了跟踪目标、合成、混合和镜头之间剪切的复杂数学和逻辑。它旨在显着减少开发过程中发生的耗时的手动操作和脚本修订的数量。
  
这些模块的程序性质使 Cinemachine 具有抗错误性。当您进行调整（例如，更改场景中的动画、车辆速度、地形或其他游戏对象）时，Cinemachine 会动态调整其行为以制作最佳镜头。例如，没有必要仅仅因为角色向左转而不是向右转而重新编写相机脚本。
  
Cinemachine 可在所有类型（包括 FPS、第三人称、2D、横向卷轴、自上而下和 RTS）中实时运行。它可以根据需要在场景中支持任意数量的镜头。其模块化系统可让您组合复杂的行为。
  
Cinemachine 与其他 Unity 工具配合良好，可作为时间轴、动画和后处理资产的强大补充。创建您自己的扩展或将其与您的自定义相机脚本集成。
  
## 2. Cinemachine 的虚拟摄像机
  
Cinemachine 不会创建新的摄像机。相反，它会引导单个 Unity 相机进行多次拍摄。您可以使用虚拟相机构图这些镜头。虚拟相机移动和旋转 Unity 相机并控制其设置。
  
虚拟摄像机是独立于 Unity 摄像机的独立游戏对象，并独立运行。它们不相互嵌套。
  
虚拟摄像机为您完成的主要任务：
  
- 在场景中定位 Unity 相机。
- 将 Unity 相机对准某物。
- 向 Unity 相机添加程序噪声。噪声模拟诸如手持效果或车辆抖动之类的东西。
  <br>
  
Cinemachine 鼓励您创建许多虚拟摄像机。虚拟相机旨在消耗很少的处理能力。如果您的场景对性能很敏感，请在任何给定时刻停用除基本虚拟摄像机以外的所有摄像机以获得最佳性能。
  
建议您使用单个虚拟摄像机进行单次拍摄。利用这一点来创建戏剧性或微妙的切割或混合
  
## 3. Cinemachine Brain
  
如其名称，是操纵所有虚拟的 Cinemachine 摄像机的大脑。它通常挂载在游戏实际摄像机上。
  
使用 Cinemachine Brain 实时响应动态游戏事件。它允许您的游戏逻辑通过操纵优先级来控制相机（自动）。
  
也可以手动使用时间轴在可预测的情况下编排摄像机，例如过场动画。

## 4. 移动和瞄准
  
使用 Virtual Camera 中的 Body 属性指定如何在场景中移动它。使用 Aim 属性指定如何旋转它。
  
虚拟摄像机有两个目标：
  
- 该跟踪目标指定虚拟相机与移动游戏物体。
- 在查找在目标指定游戏对象瞄准。
  
Cinemachine 包括各种程序算法来控制移动和瞄准。每个算法都解决一个特定的问题，并具有根据您的特定需求自定义算法的属性。Cinemachine 将这些算法实现为 CinemachineComponent 对象。使用 CinemachineComponent 该类来实现自定义移动或瞄准行为。

## 5. Cinemachine 使用简介

- 在场景中创建一个或多个“虚拟”摄像机。
- 使用 Follow 属性指定要跟随的 GameObject；使用 Look At 属性指定虚拟相机应该瞄准的游戏对象。
- 这些虚拟摄像机由一个名为 Cinemachine Brain 的组件进行管理。
- Cinemachine Brain 与 Camera 组件连接到相同的游戏对象，默认情况下，这个游戏对象将是 Main Camera 游戏对象。
- Cinemachine Brain 管理所有虚拟摄像机，并确定实际摄像机应跟随哪个虚拟摄像机（或虚拟摄像机的组合）
  
至此我们就对Cinemamachine的概念、部分组件的功能以及使用流程做了简单介绍，下节我们将开始使用这个模块为角色制作相机控制相关的功能。
  
### 【百日挑战85】unity教程之2D游戏开发初步（四十五）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》中，我们完善了unity世界交互——创建飞弹的部分，我们复习了前面关于 input manager 中检测用户输入的方法（Input.GetKeyDown），通过编写Fix 函数修复Robot的过程中学习了return关键字、取消刚体的用法，最后，我们通过 transform.position.magnitude 方法销毁不会碰撞到任何刚体的飞轮，今天我们将尝试为Robot创建Fix状态的动画及其对应的动画状态。
  
到这个阶段，我们已经实现了一些基本的游戏功能，比如我们可以操作玩家角色移动、动画、交互（减血区域、瓦片地图碰撞、机器人减血、攻击、吃血包...），但是现在问题在于当我们玩家来到瓦片地图边界时，地图并不跟随玩家移动，也就是说摄像机是固定的，这显然会限制玩家活动的区域，我们希望摄像机能跟随玩家角色移动，展示玩家到达的新的区域
  
背景：  
到目前为止，你的游戏只在一个屏幕上运行，因此你使用了一个静态摄像机。  
在本教程中，你将使用一个名为 Cinemachine 的 Unity 包来自动控制摄像机，而无需编写代码。你希望摄像机跟随你的主角，以便主角可以开始探索更大的世界。
  
1.包（Package）
  
我们需要将Package导入到项目中。Unity 附带了大多数游戏和应用程序所需的许多内置功能。某些更专业的功能并非是所有游戏都需要的，因此以包的形式来提供。包只是增加了使用这些包的项目的大小，但包的更新很快并且简单。
  
包就是一堆代码和资源，可以使用 Package Manager 将包添加到项目中。包可以为你的项目增加功能，让你无需自己编写代码，例如虚拟现实支持、后期处理效果或你在本教程中所寻找的功能：其他摄像机功能。
  
要添加 Cinemachine 包，请执行以下操作：
1.1 在 Unity 编辑器中打开 Package Manager（菜单：Window > Package Manager）。
  
1.2 找到 Cinemachine 条目，然后单击右下角的 Install。
  
1.3 Install 按钮将变为 Installing，而在包完成导入后将变为 Up to date。你现在便有了 Cinemachine，这个工具可以在项目中设置和移动摄像机。
提示：单击版本号下面的 View documentation 蓝色链接可查看包的文档。
  
众所周知，屏幕能显示的区域是由游戏摄像机（Camera）控制的，它可以展示玩家所在的区域，并呈现在屏幕上，渲染游戏的Sprite、Model、VFX、HUD等等，要操作摄像机，除了直接调用Camera组件的方法，我们还可以用 Cinemachine 帮助我们更好的控制相机，我们直接操作 Cinemachine 间接控制游戏内的 Camera 即可
  
关于 Cinemachine：Cinemachine 是一套用于操作 Unity 相机的模块。Cinemachine 解决了跟踪目标、合成、混合和镜头之间剪切的复杂数学和逻辑。它旨在显着减少开发过程中耗时的手动操作和脚本修改的数量，说白了就是一套旨在减少操作摄像机难度的控制插件。
  
2.Cinemachine 设置
  
Cinemachine 使你可以创建复杂的 3D 摄像机设置，从而允许在多个摄像机之间移动和切换。
你现在只需用来让摄像机跟随 2D 目标（跟随角色移动摄像机）。通常游戏场景范围是有限的，我们不希望玩家看到地图外的区域。所以Cinemachine 还包括 2D helper 功能，可将摄像机限制在特定边界范围内，这样就不会显示地图边界之外的对象。
  
2.1 要开始使用 Cinemachine，你需要选择对应的类型，在顶部菜单栏上选择 GameObject > Cinemachine > Create 2D Camera  条目，从而将 Cinemachine 2D 摄像机添加到场景中。
  
2.2 此时将创建一个名为 CM vcam1 的新游戏对象（表示 Cinemachine Virtual Camera 1）。
  
如上所述，Cinemachine 可与多个摄像机配合使用，并根据游戏的需要在多个摄像机之间进行切换，例如在对话中对某个镜头与反拍镜头进行切换，比如说我们可以配合Timeline组件配合多个虚拟相机实现过场动画的分镜、运镜。
  
2.3 为此，Cinemachine 使用虚拟摄像机，你可以在每个虚拟摄像机上选择不同的设置，然后告诉实际摄像机（unity的Camera组件，也可以有多个，在 Hierarchy 中名为 Main Camera）当前哪个虚拟摄像机处于活动状态，以便可以复制设置。
  
在你的示例中，只需更改 CM vcam1 虚拟摄像机上的设置，实际摄像机就会复制这些设置。
  
2.4 对于旧版本，如果打开 Game 视图，应该会看到摄像机现在看起来更远了，并且可以看到更大的世界（如果你的瓦片地图 (Tilemap) 绘制范围没有超过以前的屏幕限制，甚至可能会看到一些蓝色背景）。
  
这是因为摄像机现在使用的默认虚拟摄像机设置与以前的摄像机设置不同。
  
2.5 要再次放大，请在 vcam Inspector 中的 Lens 部分找到一个名为 Orthographic Size 的属性，并将这个属性设置为 5 而不是 10。
  
3.摄像机模式
  
在 Unity 等 3D 应用程序中，摄像机可以有两种模式：
  
1.透视：通常在3D视图中使用，一句话就是近大远小，有深度的感觉。所有远离摄像机的线都会汇聚到一个点，因此距离摄像机越远，看起来就越小。这有点像一条直路在远处消失，这条路的两边看起来就像汇聚成了一个点。
2.正交：所有平行线将保持平行。物体不会随着摄像机远近改变大小。
  
由于你处于 2D 模式，不想对象随着距离变小，因此你希望摄像机处于正交模式。
  
注意：使用 2D 模板创建项目时，摄像机便已经自动设置为正交模式。
  
简单来说，Orthographic size 是指在摄像机的一半高度内可容纳多少个单位，因为这就是摄像机的工作方式。由于我们将该属性设置为 5，所以可以在屏幕的垂直方向上看到 10 个世界单位。请确保设置为高度的一半，因此，如果希望摄像机能够看到的高度是 50 个世界单位，请将该属性设置为 25。
  
为什么要设置高度而不设置宽度？实际上，这是因为宽度会根据用户为游戏窗口设置的分辨率而变化。
屏幕可以具有很多分辨率，如 4:3、16:9 和 16:10，因此摄像机将根据屏幕形状显示不同宽度的世界，但垂直高度始终相同。
  
4.跟随主角
  
现在，我们让 Cinemachine 设置摄像机以跟随角色。
1.只需将你的主角从 Hierarchy 拖放到 vcam Inspector 的 Follow 属性中，设定要跟随的游戏对象：
  
摄像机将立即移动到位，使 Ruby 位于屏幕的中央。
2.让我们在 Scene 视图中快速绘制一个更大的世界，并在周围添加水面瓦片来阻止 Ruby 离开我们的地图。如果你不记得如何在瓦片地图上进行绘制，可以复习一下有关绘制世界的教程。
  
通过展开 CinemachineVirtualCamera 组件的Body属性，我们还可以看到一个蓝色的区域和黄色的点位，前者是游戏摄像机的实际可见区域，后者是角色的跟随点位（根据Sprite的Pivot决定）。
  
现在单击 Play 来运行场景时，你会看到当 Ruby 在地图上移动时摄像机会跟随她。但还是有一个问题：当 Ruby 走到边缘时，你可以看到地图的“外面”：
  
下期我们将学习通过 Cinemachine 设定摄像机边界。
  
### 【百日挑战86】unity教程之2D游戏开发初步（四十六）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》中，我们学习了使用一个名为 Cinemachine 的 Unity 包在不编写代码的情况下来自动控制摄像机，学习了摄像机模式：正交和透视，最后我们已经实现了摄像机跟随你的主角，今天我们将继续学习通过 Cinemachine Confiner 定义摄像机边界。
  
在上期教程中，我们尽管设置了摄像机跟随角色，但是当角色都到瓦片地图边界时，摄像机仍旧会展示背景（默认是蓝色），即使超出了地图显示区域，摄像机还是会显示背景，很难看，我们希望玩家到达地图边界时就不再继续跟随，这样就不再显示地图的边界，TileMap以外的区域，我们可以使用碰撞体配合 Cinemachine 的拓展 CinemachineConfiner 来实现。
  
5.摄像机边界
  
要阻止摄像机显示地图之外的任何内容，你需要使用 Cinemachine Confiner 定义一些边界。
要添加 Cinemachine Confiner，请转到 Virtual Camera Inspector 的底部，单击 Add Extension 下拉选单，然后选择 CinemachineConfiner：
  
新添加的组件将显示一条警告，因此需要提供一个 Collider 2D 以用作边界。Confiner 可以使用 Composite Collider 2D 或 Polygon Collider 2D。
  
让我们将一个 Polygon Collider 2D 添加到场景中：
1.单击 Hierarchy 右上角的Create 按钮并选择 Create Empty 来创建一个新的游戏对象。
2.选择这个新的游戏对象，然后将其重命名为 CameraConfiner（在 Windows 上按 F2 或在 Mac 上按 Return，选中后再次单击，或使用 Inspector 顶部的框）。
3.单击 Add Component 按钮，搜索 Polygon Collider 2D 并添加该组件。同时场景中会出现碰撞体边界，默认是五边形。
4.删除多余顶点：在 Polygon Collider 2D 上，单击 Edit Collider 旁的按钮，然后移动各个点以将这些点放在每个角的水中央。可以在拖动时按 Delete 键来删除某个点（例如五边形上最顶端的点），或者你可以在 Polygon Collider 2D 组件中将 Points > ... > Size 属性改为4，即可将碰撞体改为四边形。
5.在每个角都有一个点后，再次单击 Edit Collider 旁边的按钮设定碰撞边界区域，对于瓦片地图的四个边界点（尽量让碰撞体与瓦片地图和背景的边界重合），最后再用树、河等将边界围起来并设置碰撞体，既让其更美观也能防止玩家走出瓦片地图而摄像机无法跟随。
  
注意：请使用结尾处的点设置将值取整，确保边框是直线。不进行此设置，Confiner 也能工作，但进行此设置后会更平整。
  
6.绑定碰撞体：然后回到 vcam1 并将该游戏对象分配给 CinemachineConfiner 上的 Bounding Shape 2D 属性：
  
现在，如果尝试单击 Play 来运行游戏，你的角色将从屏幕上消失。如果在 Scene 视图中查看，就会看到角色被推到了世界之外。因为世界现在位于大型碰撞体内，所以物理系统会直接将你的角色推出去。说明碰撞体不但作用在摄像机上并且作用在游戏对象的刚体上，这是我们不希望的，我们不希望这个 Polygon Collider 2D 与除摄像机外的其他物体碰撞，我们可以通过设置特定的Layer解决不同层级碰撞问题。
  
7.找回你的角色
  
要将角色带回场景中，需要使用图层 (Layers)，就像在上一教程中对飞弹进行的操作一样。请参阅该教程以了解更深入的介绍，但在这里我们也简要提醒一下所需的步骤：
1.在 Inspector 的右上角，单击 Layer 下拉选单，然后选择 Edit Layer。
2.选择一个空字段并将其命名为 Confiner。
3.在 Confiner 游戏对象上，将 Layer 下拉选单设置为 Confiner。
  · 选择 Edit > Project Settings > Physics 2D，默认是全选的，然后取消勾选 Confiner 图层中的所有条目，即不和任何层的刚体发生碰撞：
  
现在，再次Confiner 图层中的所有对象都不会与其他对象碰撞。进入运行模式，然后操纵 Ruby 四处移动。现在摄像机将跟随Ruby移动并将停在地图边缘，我们不会再看到瓦片地图外的蓝色背景了，可见Cinemachine大大简化了用户对摄像机的控制。
  
8.总结
  
在本教程中，你将 Cinemachine 包导入到了 Unity 中并使用了这个包来处理摄像机移动。
  
要获得有关如何使用 Cinemachine 的更多信息，特别是如果你要尝试使用虚拟摄像机属性（例如阻尼移动以及跟随或跟随速度），请查看相关文档。
  
提示：请注意一下 Package Manager，因为其中包含的包不但可以帮你创建游戏，还可以减少你的工作量。
  
在下一教程中，你将了解如何使用粒子系统 (Particle System) 进行图形方面的一些改进。
  
### 【百日挑战87】unity教程之2D游戏开发初步（四十七）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》中，我们学习了使用一个名为 Cinemachine 的 Unity 包在不编写代码的情况下来自动控制摄像机，通过 Cinemachine Confiner 拓展配合Polygon Collider 2D 组件实现相机碰撞定义摄像机边界，至此我们就通过Cinemachine实现了角色的跟随和摄像机的边界。今天我们将开始学习unity内置粒子系统 (Particle System) 进行图形方面的一些改进。
  
在开始新的内容之前按，我们先填下前面的一个坑——修复Robot的动画，创建Fix状态的动画及其对应的动画状态。
背景：我们希望当Ruby修复完机器人后播放动画，我们将为修好的机器人添加动画。请参阅前面教程，了解有关如何创建动画和使用 Animator 的更多详细信息。
  
1.新增Fix状态的动画剪辑：使用Animation窗口，点击 Create New Clip...，为敌人创建一段新的动画剪辑（使用 MrClockworkFixed 帧 1、2、3 和 4），命名为 RobotFixed。别忘了把 Sample 设置成 4。
  
2.找到素材：你可以在 Art > Sprites > Characters 文件夹内（位于名为 MrClockworkSheet 的精灵图集 (Sprite Atlas)（也称为精灵图集 (Sprite Sheet)中），展开，选择以下全部四个精灵 MrClockworkFixed1...的关键帧拖放到 Animation 窗口中。此时将使用四个精灵来创建一段动画。
  
3.选中Robot对象打开Animator窗口，RobotFixed 状态已经自动为我们创建了，在 Enemy Animator 中，创建从 Move 的“混合树”到这段新动画的过渡。
  
点击新建的过渡，别忘了禁用 Has Exit Time。该状态无需退出，无需进行反向的过渡，也不需要任何额外的参数和混合blendtree，我们只需要一个进入该状态的条件即可，因为机器人在修好后，就一直保持修复状态，而不需要退出该状态。
  
4.添加参数：创建类型为 Trigger 且名为 Fixed 的参数，并将此参数作为由 Move 到Fixed 的条件，一旦接受到了 Trigger 的参数，就会触发这个过渡。将其设置为过渡条件：
  
5.添加触发状态的方法：在EnemyController组件的Fix()函数内，添加以下代码：animator.SetTrigger("Fixed"); 告诉animator要过渡到该状态：机器人已经修好了。
  
6.进入运行模式，朝着机器人发射齿轮以将机器人修复。机器人现在应该活蹦乱跳了！

  

<br>
<hr>
<br>

配套视频教程：
[https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912](https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912)

文章也同时同步微信公众号，喜欢使用手机观看文章的可以关注

![](../../imgs/微信公众号二维码.jpg)
