# 2D 物理系统入门
  
背景：通过前面几章对瓦片地图 Tilemap 系统的介绍，相信大家已经能熟练的使用素材以及各项工具绘制我们场景中的地图了，但是如果我们仔细试玩的时候会发现一个问题，角色可以在地图中任何位置移动，比如我们的Ruby可以浮在水池上面，直接穿过树木，箱子，甚至地面，这显然是不符合逻辑的，我们希望玩家不能通过某些特殊的区域或者物体，其实思路很简单：如果我们不希望玩家通过一些地方，就让玩家身上的刚体和发生碰撞，阻挡玩家通过这些区域即可，为此，你将使用 Unity 提供的另一大系统：物理系统 (Physics System)。
  
目标：我们的目标是解决玩家与物体正确碰撞并在TileMap上设置特殊区域处理玩家与瓦片地图之间的碰撞。
  
> [2D 物理系统官方手册](https://docs.unity3d.com/cn/2021.2/Manual/Physics2DReference.html)

本节主要讲 2D 物理系统中的碰撞体和刚体，2D 关节和效应器会在后面的课程中讲解
  
## 1. 开始之前：什么是物理系统？
  
学习物理时，你会发现所有的对象移动都是作用力组合的结果。例如，如果你尝试推动箱子，作用在箱子上的力包括：
  
· 重力（将箱子往下拉）
· 作用力（你施加来推动箱子的力）
· 地面摩擦力（阻碍推动）
  
在游戏开发的各项需求中，我们常常会用到一些模拟现实世界物理现象的操作，如果你要模拟移动和碰撞，需要使用所有数学公式来计算对象上的接触和力。但这需要编写很多复杂的代码。由于物理定律是相同的，因此可以抽象出此代码并在所有游戏中进行共享：这就是物理系统的功能。Unity 有一个内置的物理系统，可以为你计算对象的移动和碰撞。为避免对我们游戏中的每个对象进行成本高昂的数学运算，Unity 仅对附有 Rigidbody 2D 组件的游戏对象执行这些计算。
  
如果不使用游戏引擎自带的物理引擎实现就会很麻烦，而这样底层的轮子unity已经帮我们造好了，我们直接添加各种组件，配置参数就可以实现各种复杂的物理效果，而模拟刚体间碰撞是物理引擎最基础的一个部分，我们可以用它模拟2D/3D游戏阻挡玩家穿过某些地方或者让玩家站在一个物体上，这也是使用游戏引擎开发效率高的主要原因之一。
  
### 1.1 向玩家添加2D 刚体 Rigidbody 2D
  
我们在项目中演示下如何实现这样的碰撞。要实现碰撞，至少需要两个物体，这里我们选取Ruby和MetalCube两个对象。
  
1. 在 Hierarchy 中，选择 Ruby 游戏对象。
2. 将 Ruby 游戏对象从 Hierarchy 拖入 Project 窗口中的 Prefab 文件夹，生成预制件，这是一个好习惯，方便后期重复使用对象。
3. Asset中双击 Ruby 预制件以打开预制件模式。在 Inspector 中，单击 Add Component 按钮。
4. 搜索“Rigidbody 2D”，然后选择该组件。找到Gravity Scale（重力大小） 属性并将其设置为 0，不让物体下落，这节先不考虑玩家与TileMap的碰撞。
5. 使用 Save 按钮或者Ctrl+S快捷键来保存预制件，然后返回到场景。
  
### 1.2 向游戏对象添加碰撞体
  
在我们讲解添加碰撞体（Collider）之前，我们先来了解什么是碰撞体？当我们添加完Rigidbody之后，物理系统已经识别你的游戏对象（由于刚体），接下来你需要告诉物理系统，该游戏对象的哪一部分是“实心的”。此操作是通过碰撞体完成的。
  
碰撞体是简单的形状（例如正方形或圆形），物理系统将这样的形状作为游戏对象的近似形状来进行碰撞计算。尽管碰撞体在运行时可能不会显示，但是这个碰撞体积是实实在在存在于我们世界空间中的。
  
我们先试着为Ruby添加2D碰撞体：
  
1. 在预制件模式下打开 Ruby 预制件。
2. 在 Inspector 中，单击 Add Component。
3. 搜索“Box Collider 2D”，然后添加此组件。
4. 现在，你会在 Scene 视图中看到 Ruby 周围有绿色的轮廓线：
5. 这就是碰撞体的形状，现在物理系统会将这个形状作为 Ruby 的形状。
  
由于碰撞是相互的，所以我们同样还要给 MetalCube 添加一个Collider
  
1. 将 MetalCube 游戏对象从 Hierarchy 拖入 Project 窗口中的 Prefab 文件夹，生成预制件，双击打开这个进入预制件编辑模式。
2. 在 Inspector 中，单击 Add Component，搜索“Box Collider 2D”，然后添加此组件。
3. 保存预制件并退出预制件编辑模式。
  
问题：为什么不需要为MetalCube添加Rigidbody？这是因为不需要通过物理来移动箱子，只需要一个碰撞体即可，无论有没有刚体，游戏对象都将与箱子交互。
  
完成以上步骤之后，点击Play运行游戏，然后尝试让 Ruby 穿过箱子以及在箱子周围移动，可以发现两个很大的问题：当Ruby碰到我们的箱子移动的时候会不断抖动并旋转，以及Ruby还没碰到箱子的时候就发生碰撞了。我们先来解决第二个问题。
  
三：疑难解答  
由于碰撞的检测是由碰撞体的位置和形状（边缘）决定的造成碰撞效果的，不真实接触效果的原因是碰撞体积设置的太大了。解决方法如下：
  
1. 在预制件模式下打开 Ruby 预制件，找到Box Collider 2D组件并选中，点击Edit Collider可以编辑碰撞区域，绿框显示的是碰撞体的形状
2. 在我们的2D游戏中，为了让角色适应透视视角的需求，我们的碰撞体也要按照相应的需求进行设置。可以拖动四周的绿点或者修改Box Collider 2D组件的偏移、大小，让碰撞体的位置在角色的下半身即可，这样就让碰撞符合透视的效果。
3. 保存预制件并退出预制件编辑模式。
4. MetalCube的Collider修改方式也是与之类似的，我们就直接在预制件里面找到选中Box Collider 2D组件，点击Edit Collider，考虑到符合透视的视角效果，我们要将碰撞区域的长和宽缩小到这个箱子一个面边长所在的区域即可。
5. 保存预制件并退出预制件编辑模式。
  
我们再来解决第二个问题：Ruby的旋转问题。
  
首先，让我们处理旋转问题。为此，你需要告知 物理系统不要旋转游戏对象。这在“真实”的物理中也许是可行的，但在此 2D 游戏中不起作用。
  
幸好，Rigidbody 2D 组件具有与此相关的设置：
  
1. 确认 Ruby 已在预制件模式下打开。
  
2. 在 Inspector 中，找到 Rigidbody 2D 组件。
  
3. 单击 Constraints 旁边的小箭头以展开该部分。
  
4. 启用 Freeze Rotation 复选框以确保刚体不会向 Ruby 添加任何旋转。
  
提示：如果你在场景中（而不是在预制件上）对 Ruby 实例进行此更改，请使用 Overrides 下拉菜单将更改应用于你的预制件。
  
保存并再次运行游戏，这次Ruby和箱子的遮挡以及碰撞都是符合透视效果的，并且绕箱子移动时候再也没有出现旋转的情况了。
  
## 【百日挑战56】unity教程之2D游戏开发初步（二十）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，系统性的学习了unity的2D游戏开发中的物理系统。了解了其作用和重要概念，然后带大家在编辑器里面实现了让箱子挡住玩家Ruby，掌握了如何通过unity引擎在2D游戏中使用物理系统解决游戏对象之间的碰撞，今天我们继续解决上期遗留的问题：角色于碰撞体交互抖动。
  
上期我们解决了两个问题：1、当Ruby碰到我们的箱子移动的时候会不断抖动并旋转 2、Ruby没碰到箱子的时候发生碰撞了。这期我们继续解决Ruby发生碰撞时抖动的问题。
  
### 2.1 解决问题

首先我们分析下抖动是如何产生的？我们回到角色控制移动的代码，我们角色位置的改变是通过Transform变换（transform.position）实现的，但是Transform组件本身并不会考虑物理碰撞，只会根据键盘输入将对象移动到某个位置(Position)，他不会考虑我们的位置是在碰撞范围内，所以每次执行Update的时候，Ruby都会先移动，移动到箱子的碰撞体内，然后物理引擎的刚体再将玩家挤出去，即物理引擎先检测位置，物理引擎再将物体挤出碰撞体外，然后Transform组件又将玩家移动到碰撞体范围内，然后刚体又将玩家挤出碰撞体外，循环往复，导致Ruby在不断的抖动，说明通过Transform组件控制玩家移动已经不适合当前有碰撞体的情景了。
  
我们要使用刚体的移动位置的方法取代我们现有的角色移动方式：即通过刚体获取当前对象的position，然后处理完物理部分之后给它赋值一个新的位置，这样就能通过应用刚体的Transform完全阻挡玩家穿过Collider的碰撞区域了。
  
1. 要解决 Ruby 的抖动问题，你需要移动刚体本身而不是游戏对象变换组件，并让物理系统将游戏对象位置同步到刚体位置。这样，物理系统就可以在进入箱子之前停止移动，而不必在 Ruby 已经进入箱子之后再移动 Ruby。
2. 双击 RubyController 脚本以将其打开。你的脚本应如下所示：
  
如下所示调整 RubyController 脚本（注意阅读注释）：  

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RubyController03 : MonoBehaviour
{
    //声明刚体对象
    Rigidbody2D rigidbody2d;
    //获取用户输入
    float horizontal;
    float vertical;
    //注意：如果要在多个方法里面调用相同的变量，则变量需要在方法外声明

    // 将速度暴露出来，使其可调
    public float speed = 0.1f;

    //只需在游戏开始之前获取当前游戏对象的刚体组件，不需要一直获取
    private void Start()
    {
        rigidbody2d = GetComponent<Rigidbody2D>();
    }
    // 每帧调用一次 Update
    void Update()
    {
        horizontal = Input.GetAxis("Horizontal");
        vertical = Input.GetAxis("Vertical");

    }
    //Update()方法在不同帧率下执行次数不一样，我们希望以固定的频率执行某些代码需要用到FixedUpdate()方法，使物理计算保持稳定
    //固定时间间隔执行的更新方法
    private void FixedUpdate()
    {
        Vector2 position = transform.position;
        position.x = position.x + speed * horizontal * Time.deltaTime;
        position.y = position.y + speed * vertical * Time.deltaTime;
        rigidbody2d.position = position;
    }
}

```
  
注意：  

1. 默认情况下，所有游戏对象都具有一个 Transform 组件，所以 Unity 使 transform 变量在所有脚本中都可用。但是，必须将 Rigidbody 组件手动添加到游戏对象，因此 Unity 并没有将这个变量作为内置变量。
2. 除此之外，物理系统的更新速度与游戏不同。每次游戏计算新图像时都会调用 Update，问题是调用速度不确定。在一台速度较慢的计算机上，调用速度可能是每秒 20 张图像，而在一台非常快的计算机上，调用速度可能是每秒 3000 张图像。
  
为了使物理计算保持稳定，需要定期进行更新（例如，每隔 16ms）。Unity 还有另一个名为 FixedUpdate 的函数，只要你想直接影响物理组件或对象（例如刚体），就需要使用该函数。
但是，你不应该读取 Fixedupdate 函数中的输入。FixedUpdate 不会持续运行，因此有可能会错过用户输入。你需要在类中添加两个浮点变量，以便在 Update 函数内存储当前的水平和垂直输入数据。
  
总之，只要是涉及到需要固定时间间隔或者的频率的逻辑都需要写在FixedUpdate()方法内保证不同平台执行频率相同。
  
### 2.2 审查更改

让我们来看看新的和调整的每行代码：
  
· Rigidbody2D rigidbody2d;
  
此行代码将创建一个新变量（名为 rigidbody2d）来存储刚体并从脚本中的任何位置访问刚体。
  
· float horizontal;
float vertical;
  
这两行代码将创建两个新变量来存储输入数据。这些变量曾在 Update 函数中声明过，但是由于你现在需要从另一个函数 (FixedUpdate) 访问这些变量，因此在此处又声明了这些变量。
  
· rigidbody2d = GetComponent<Rigidbody2D>();
  
此代码位于 Start 函数内，因此在游戏开始时仅执行一次。此代码要求 Unity 向你提供与脚本附加到同一游戏对象（即你的角色）上的 Rigidbody2D。
  
· 在 Update 函数中，你删除了与移动相关的所有代码。你保留了用于读取输入的代码，这次是位于先前声明的两个变量中。
  
· Vector2 position = rigidbody2d.position;
  
在 FixedUpdate 函数中，你添加了曾位于 Update 函数中的代码行，并调整了此代码以使用刚体位置。
  
· rigidbody2d.MovePosition(position);
  
同样，你现在使用刚体位置，而不是使用 transform.position = position; 来设置新位置。这行代码会将刚体移动到你想要的位置，但是如果刚体在移动中与另一个碰撞体碰撞，则会中途停止刚体。
  
### 2.3 运行查看效果

保存，再次运行可以看到你的角色已停止抖动！
  
### 【百日挑战57】unity教程之2D游戏开发初步（二十一）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，继续学习了unity的2D游戏开发中的物理系统。了解了如何在代码中使用刚体组件控制玩家移动，以及FixedUpdate方法作用和使用情景，最后带大家改进了玩家Ruby的控制器，解决了传统Transform组件移动造成刚体与碰撞体接触发生抖动的问题，今天我们继续实现玩家与TileMap的碰撞
  
一、在开始之前，我们先讲下上期用到的各种概念：
  
1. 关于MonoBehaviour.FixedUpdate ()方法：  
用于物理计算的帧速率独立的MonoBehaviour.FixedUpdate消息。
MonoBehaviour.FixedUpdate具有物理系统的频率；它被称为每个固定帧速率帧。在FixedUpdate之后计算物理系统计算。0.02 秒（每秒 50 次调用）是调用之间的默认时间。使用Time.fixedDeltaTime来访问该值。通过在脚本中将其设置为您的首选值来更改它，或者导航到此处并将其设置。FixUpdate频率或多或少于Update 。如果应用程序以每秒 25 帧 (fps) 的速度运行，Unity 每帧大约调用两次，或者，100 fps 会导致大约两个渲染帧带有一个固定更新。从设置中控制所需的帧速率和速率。使用Application.targetFrameRate设置帧速率。使用Rigidbody时使用FixUpdate。为Rigidbody设置一个力，它会应用每个固定框架。FixUpdate发生在通常与MonoBehaviour.Update不一致的测量时间步长，你也可以手动设置更新间隔：Edit > Settings > Time > Fixed TimestepFixed TimestepTime（固定时间步进）。
  
不建议将获取用户输入的代码放到该方法下，由于更新频率较慢会造成输入的延迟，影响流畅性。
  
### 3.1 添加瓦片地图碰撞

现在，你的角色会与我们具有碰撞体的所有游戏对象碰撞。但是她仍然可以在水上行走，因此你应该让她与水面瓦片碰撞，使她不能在水上行走。但如何才能做到呢？
  
你可以在空游戏对象上添加一个碰撞体，然后调整碰撞体大小以涵盖水面。但这个过程容易出错，如果你想将水面重新绘制得更大、更小或绘成其他形状，则必须手动更改碰撞体。请注意，这种情况下通过瓦片地图可以轻松快速地更改世界。
  
幸好，瓦片地图也可以具有碰撞体。无论是否应该碰撞，每个瓦片都可以存储起来，并且瓦片地图碰撞体将为所有要设置以进行碰撞的瓦片创建碰撞体。
  
要设置瓦片地图碰撞体，请执行以下操作：
  
1. 在 Hierarchy 中，选择 Tilemap 游戏对象。

2. 在 Inspector 中，单击 Add Component 按钮。
  
3. 搜索“Tilemap Collider 2D”，然后选择此组件。你会看到在 Scene 视图中为所有瓦片添加绿色碰撞体方块（绿色方格是每个碰撞体的碰撞区域）：
4. 运行游戏，我们的Ruby只能在当前的方格移动，这是因为现在所有的瓦片都已设置为进行碰撞。
5. 我们希望只有一部分TileMap可以发生碰撞，我们可以直接设置Tile的属性，为每个Tile配置碰撞
6. 在 Project 窗口中，找到 Tile 文件夹，里面存放了我们分割的瓦片，选中待修改的瓦片（希望玩家能穿过的瓦片），在 Inspector 中，找到 Collider Type 属性，然后将该属性从 Sprite（目前值）更改为 None。默认情况下碰撞体积是根据Sprite的体积自动划分。
7. 保存，单击 Play 以进入运行模式，并尝试让 Ruby 在水上行走。她现在应该会与边界发生碰撞。
8. 以上就是在TileMap中设置碰撞基本方式，如果我们希望修改Rule Tile中每个小Tile的规则，可以在Tiling Rules中配置每个Tile的Collider规则。
9. 如果是Rule Override Tile（规则覆盖瓦片）则不能这样处理了，它的规则是继承Tile的，没法直接修改，如果你不希望修改父级的Tile你可以创建Advanced Rule Override Tile先继承Tile之后再微调规则里的Collider。
  
· Rule Override Tile无法直接修改当前瓦片的规则  
· Advanced Rule Override Tile可以选择性继承规则并配置每个瓦片的属性
  
### 3.2 优化瓦片地图碰撞体

最后一小步是设置瓦片地图碰撞体。目前，正如在 Scene 视图中看到的，每个瓦片都是一个单独的碰撞体。
  
这种方法效果良好，但会产生两个问题：
  
· 物理系统的计算量更大；如果碰撞区域比较大，可能会减慢你的游戏速度。
· 在瓦片之间的边界上会产生小问题。由于瓦片是两个并排的碰撞体，并且两者之间存在微小间隙，因此有时计算上的微小误差也可能导致仍会发生碰撞的罕见情况。
  
为了解决这些问题，Unity 提供了一个名为 Composite Collider 2D 的组件。此组件可以获取对象（或对象的子对象）上的所有碰撞体，并由此创建一个大碰撞体。
  
让我们来添加并配置此组件：
  
1. 在 Hierarchy 中，选择 Tilemap 游戏对象。
  
2. 在 Inspector 中，单击 Add Component 按钮。
  
3. 搜索“Composite Collider 2D”，然后选择此组件。
你会看到自动添加 Rigidbody 2D 组件，因为复合碰撞体需要 Rigidbody 2D 才能正常运行。
  
4. 在 Tilemap Collider 2D 组件中，启用 Used By Composite（由复合使用） 复选框。
  
5. 在 Rigidbody 2D 组件中，将 Rigidbody Body Type 属性设置为 Static，由于瓦片地图是固定的，不需要考虑移动，此做法可以进一步减少性能开销。
  
将此属性设置为 Static 将阻止你的世界移动。此外还有助于物理系统优化计算，因为它现在知道刚体不能移动。
  
至此，我们就学习了如何在多种规则瓦片地图中添加瓦片地图碰撞并优化瓦片地图碰撞体性能。
  
### 【百日挑战58】unity教程之2D游戏开发初步（二十二）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，继续学习了unity的2D游戏开发中的物理系统。了解了TileMap Collider组件的用法，实现了在多种规则瓦片地图中添加瓦片地图碰撞并通过Composite Collider 2D 组件合并瓦片地图优化碰撞体性能，今天我们继续学习2D伪透视下碰撞和遮罩关系
  
1. 我们先重新根据之前配置的素材美化了下我们的瓦片地图，对于一些形状复杂的物体，Box Collider就不适用了，而且碰撞区域设置起来也很麻烦，我们可以直接为该物体添加Polygon Collider 2D（多边形碰撞器），无需编辑开箱即用，尽管使用起来很方便，但性能消耗稍大，而且无法直接编辑碰撞区域，请大家根据需求酌情使用。
  
2. 对于需要处理透视的物体，我们仍然要使用可编辑形状的碰撞体手动编辑碰撞区域让透视更符合逻辑。
  
注意：在Box Collider 2D组件中，Offset（偏移）和Size（大小）的X，Y坐标都是相对于中心点（枢轴）的（蓝色的圈）计算的相对位置，如果需要修改枢轴的位置需要在Assets里面选中Sprite然后使用Sprite Editor编辑其位置，这样碰撞体的位置都会相对这个枢轴确定，可以更方便我们设置碰撞体，由于枢轴位置的改变也会影响碰撞区域的位置，建议在设置Collider之前先确定好轴心，再来设置碰撞区域，避免返工影响效率。
  
比如下面这个house，我们希望碰撞体的范围是相对于这个枢轴确定，一个是方便设置碰撞区域，其次是让图层排序符合透视规律，这样一旦检测到玩家Ruby脚底的碰撞范围与这个门的Collider接触就会触发一系列事件，比如对话，切换场景等。
  
修改枢轴位置之后，我们还要在 House 和 Ruby 的Prefab中将Sprite Render中的Sprite Sort Point（Sprite 排序点）属性改为Pivot（轴心），该选项作用是计算 Sprite 和 Sprite 之间的距离时，选择 Sprite 的中心或其枢轴点相机。该选项会影响图层的排序的位置。
  
注：关于Sprite Sort Point（Sprite 排序点）：
  
仅当 Sprite Renderer 的绘制模式设置为Simple时，此属性才可用。
  
在 2D 项目中，主摄像机默认设置为正交投影模式。在此模式下，Unity 按照距相机的距离顺序沿着相机视图的方向渲染精灵。
  
· 正交相机：侧视图（顶部）和游戏视图（底部）
  
默认情况下，Sprite 的排序点设置为其Center，Unity 会测量相机的变换位置与 Sprite 中心之间的距离来确定它们的渲染顺序。
  
要设置与中心不同的排序点，请选择“枢轴”选项。在Sprite Editor中编辑 Sprite 的枢轴位置。
  
作业：将其他的树也按照上述方法设置俯视角透视的图层排序方式以及为他们设置碰撞体。
  
### 【百日挑战59】unity教程之2D游戏开发初步（二十三）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，继续学习了unity的2D游戏开发中的物理系统和Sprite Renderer排序的相关内容。学习了Polygon Collider 2D组件的使用，了解了Sprite Sort Point的作用以及如何在Sprite Editor中调整轴心，今天我们继续学习使用触发器实现可收集对象以及通过代码为角色设计生命系统。
  
背景：在游戏开发中，我们经常会出现玩家触发npc对话，触发任务，拾取物等需要交互的情况，这种操作同样可以通过碰撞体检测，与常规的Collider不同，它需要充当Trigger（触发器）的角色。
  
一、通过C#脚本实现可收集对象
  
4.1 向 Ruby 添加生命值统计功能
  
目标：我们要向 Ruby 添加生命值的属性，并通过拾取相应的道具回复生命值，当生命值耗尽需要执行相应的行为。
  
提示：可补充角色生命值的生命值包是演示可收集对象的一个良好示例。但是你需要首先向 Ruby 提供一些生命值，然后才可以补充 Ruby 的生命值。
  
众所周知，如果我们需要设计一套生命值系统，我们需要两个值，一个用于记录当前的生命值，该值只由运行逻辑修改，为了保证安全性不允许被随意修改，另一个用于存储玩家最大生命值（生命上限），可根据策划要求随时进行修改，并在角色获得经验等级上升的同时相应提升，我们先不设计的那么复杂，我们的目前的规则当前等级的玩家最大生命值不能超过生命上限。

操作具体步骤如下：

1. 首先打开之前创建的 RubyMoveController 脚本。这是我们要修改的脚本。
2. 然后对RubyMoveController 脚本添加命名空间：Player.Ruby，将整个类都用大括号括起来，用于隔离类名避免冲突。
3. 我们希望生命值要能在游戏的流程中被更改，我们首先要在Assets/Scripts路径下创建一个名为RubyHealthSystem的C#脚本，并在其中书写关于Ruby伤害的方法。创建完之后打开脚本进行编辑。
4. 同样是添加命名空间：Player.Ruby，将整个类都用大括号括起来。
5. 在RubyHealthSystem脚本，先定义两个变量：float类型的公有变量maxHealth（最大生命值），初始值为5，以及int类型的私有变量amount（当前生命值），这些是待会计算生命值需要使用到的变量，我们使用currentHealth = maxHealth; 语句在 Start 函数中将maxHealth赋值给当前生命值，即可将当前生命值初始化为最大生命值，因此在游戏开始时，角色处于满血生命值状态，至此，我们就完成了游戏数值上的设定。
6. 我们再定义一个新的函数封装我们关于伤害计算的类，无返回值用void类型，名字取为ChangeHealth，小括号里面填上要传入的参数类型和名称：int amount，然后添加以下代码：
7. 我们还没有调用我们写的新方法，为了方便测试，我们回到RubyMoveController 脚本，开头一定要先声明我们的方法类类名 RubyHealthSystem 和字段，字段名称可以随意，我这里以healthSystem为例，接着复习下如何调用对象的方法成员（函数）：对象名.成员方法(实参列表)，直接调用方法名会提示：当前上下文中不存在名称“xxx”，最后在FixedUpdate方法调用RubyHealthSystem方法，小括号里面是传入的是要增加的生命值，这样每调用一次FixedUpdate就会让生命值+1，最后将healthSystem组件挂载到玩家对象即可。
8. 在 Console 窗口中显示生命值：最后，你通过添加相关代码，借助 Debug.Log 在 Console 窗口中显示当前生命值。每次生命值变化时，此脚本都会更新控制台。
在我们的游戏中没有任何图形或文本可以显示 Ruby 的生命值，因此你可以检查控制台来查看一切是否正常。
为了更容易在控制台中读取生命值，你使用了 + 将字符串合并为一个方便阅读的短语。在此示例中，你在 currentHealth 和 maxHealth 之间插入了一个斜杠 (/)。
9. 运行，可以看到控制台报错：NullReferenceException: Object reference not set to an instance of an object，这是因为在对象被引用前没有实例化。
10. 回到RubyHealthSystem脚本，添加一行 healthSystem = GetComponent<RubyHealthSystem>(); 这也是新手常犯的错误，在跨组件类调用对象内方法时候一定要先在Start方法内用GetComponent<>方法实例化对象，不然就会出现丢失引用的问题。
  
11. maxHealth输入最大值，保存再次运行观察我们Ruby的生命值是不是增长到我们设置的maxHealth之后便不再增长了。
  
注：通过这次教程我们学习了很多知识点，吸取了很多经验教训。
  
1. 为了方便后期维护，我并不建议将伤害的类与控制角色的类都写入同一个脚本中，相反，我们应该为代码加上命名空间，将与Ruby伤害有关的类与控制Ruby移动的类写在同一命名空间下，这里取名叫Ruby，这个命名空间专门用来存放和玩家Ruby有关的逻辑，关于使用命名空间的优势前面已经介绍过了，其一是起到隔离作用避免命名冲突，不同的命名空间中可以有相同的类名（虽然不建议这样做），因为它们彼此独立。其二是命名空间将相关的代码组织在一起，使得代码结构更清晰和易于理解。我们可以根据功能或模块将相关的代码放在同一个命名空间中，以便更好地组织和管理代码，总之，这是有效提高代码的可读性和可维护性的好习惯。
2. 关于封装：可以看到，我们在一个新的RubyHealthSystem脚本内将currentHealth方法封装成了一个新的名为ChangeHealth类并在原先的RubyMoveController脚本中调用它，函数封装可以能够使代码更具可重用性，因为该函数可以在程序的多个地方调用，同时也可以提高数据安全性，即隐藏对象的属性和实现细节，仅对外公开接口，比如在设计多线程异步驱动时，内部的类也不能让外界访问，更不能轻易给修改权限，此外，函数封装还可以降低程序耦合度，让其他人更容易读懂。
3. 关于函数声明：在我们开始写一个函数的时候，第一行被称为函数声明，看起来很像 Start 和 Update 函数（函数声明告诉编译器如何编译该函数）：
  
void ChangeHealth(int amount){ }
  
让我们对其进行分解说明：
· 首先是 void，这是函数的返回类型。此处的 void 表示“无”，因为该函数不会返回任何值，只更改生命值。  
· 然后，你将函数命名为 ChangeHealth。  
· 与 Start 和 Update 函数不同，此函数的括号内有一个变量，这是一个参数。该参数是对生命值的更改量，因此你可以向函数赋值 2 或 -1（或任何其他整数）。
  
注意：你已经在 rigidbody.MovePosition 中使用过参数（在 4 -“世界交互 - 阻止移动”中），当时将新位置放在括号中。之所以使用括号是因为要调用 Unity 提供的 MovePosition 函数。完整的 MovePosition 函数声明是 void MovePosition (Vector2 newPosition)。
4. 关于Mathf.Clamp()方法：我们来看看 ChangeHealth 函数的主体，即花括号内的代码：
  
这里使用了另一个名为 Mathf.Clamp 的内置函数来设置当前生命值。这是因为，在 Ruby 处于生命值满血状态时，如果你尝试将生命值增大 2，生命值便会超过最大值。同样，如果 Ruby 剩下的生命值为 1，而你尝试减少 2，则 Ruby 的生命值将为负，这显然是不符合要求的。
我们希望Ruby的生命有一个限度，最低只能是0，最高可以是maxHealth，不能超过生命上限。
  
比如说Ruby的生命上限为5，下限为0，就算再拾取血包，当前的生命值到了5之后便不会再增长了，那么生命值所处的范围就是0~5，我们就需要一个可以设置取值范围的函数确定生命值的上限和下限，不管超出最大值还是小于最小值，我们的currentHealth值还是会在这个范围内，即超出最大值就为maxHealth的值，超出最小值就为最小值0，这就叫钳制。
  
钳制功能 (Clamping) 可确保第一个参数（此处为 currentHealth + amount）绝不会小于第二个参数（此处为 0），也绝不会大于第三个参数 (maxHealth)。因此，Ruby 的生命值将始终保持在 0 与 maxHealth 之间。
  
5. 关于NullReferenceException错误：错误的意思翻译过来是“未将对象引用到对象的实例”，意思就是声明了对象，却没有给它赋值，导致运行的时候依旧是null值。这是新手常犯的一个错误，比较常见的原因是就是在对象被引用前没有实例化，除了要注意用GetComponent<>方法实例化对象，还需要注意如果脚本存在上下调用关系最好不要在相同的生命周期中使用。比如两个都在Start中的对象引用，被一引用的那个对象的实例化最好放在Awake中。如果一定要在相同的生命周期中调用，比如都在start，那你就要计算好他们的顺序，当然，这种做法是不建议的。
  
以下是unity的MonoBehaviour生命周期，大家有兴趣可以自行了解。
  
### 【百日挑战61】unity教程之2D游戏开发初步（二十四）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，通过C#脚本实现可收集对象中的向 Ruby 添加生命值统计功能，通过自定义函数 ChangeHealth 初步实现了一套简单的生命值系统，学习了使用Clamp函数为Ruby设置生命上限和下限，以及使用命名空间隔离类和面向对象函数的封装的方法和优势，并盘点了新手常见的问题，今天我们继续完善角色设计生命系统并使用触发器实现创建可收集的生命值游戏对象。
  
在正式开始今天的内容之前先来回答上次课程留下的问题：
  
1. 为什么Mathf.Clamp()函数可以直接调用而不用声明我们的方法类类名 RubyHealthSystem 和字段？
   Mathf作为unity提供的内置函数，我们通过翻阅unity的api文档可以看到，Mathf是一个静态类，Mathf.Clamp()是静态类的一个静态方法，无需创建对象实例化即可调用方法。
2. 关于 Mathf.Clamp 方法：public static float Clamp (float value, float min, float max);
   参数：value 浮点值，限制在最小值和最大值定义的范围内。
   min 要比较的最小浮点值。
   max 要比较的最大浮点值。

   返回：float 最小值到最大值之间的浮点值结果。

   描述：在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。
   如果给定的浮点值小于最小值，则返回最小值。如果给定值大于最大值，则返回最大值。使用 Clamp 可将某个值限制为最小值和最大值定义的某个范围内。
  
开始之前：什么是触发器？
  
你现在已经为主角添加生命值，接下来让我们添加一种获取生命值的方法。  
为此，你将使用触发器。触发器是一种特殊类型的碰撞体。触发器不会阻止移动，但是物理系统仍会检查角色是否会与触发器碰撞。当你的角色进入触发器时，你将收到一条消息，以便你可以处理该事件。
2D 刚体组件将对象置于物理引擎的控制之下，和 3D 标准刚体不同，刚体在 2D 中，对象只能在 XY 平面中移动，并且只能在垂直于该平面的轴上旋转。
  
操作步骤：创建可收集的生命值游戏对象
  
1. 这里我们要添加一个可以被Ruby拾取的血包，让我们先创建一个可收集的生命值游戏对象：
2. 首先，重复你在上一教程中遵循的所有步骤以制作金属箱：
   · 在 Project 窗口中，选择 Assets > Art > Sprites > VFX，并找到 CollectibleHealth。
   · 将这个游戏对象导入到场景中，并调整 PPU 值或Transform组件的Scale值以设置为适当大小并放在合适的位置。
   · 将 Box Collider 2D 组件添加到新游戏对象，调整碰撞体大小，以便更好地适应精灵。
   · 在 Inspector 中，找到 Box Collider 2D 组件。启用 Is Trigger 属性复选框。
   · 最后在Assets/Prefabs 路径下将该对象制作为预制件方便素材复用。
3. 现在，如果你单击 Play，如果不勾选 Is Trigger 属性就像 Ruby 会与箱子碰撞一样，她也会与生命值可收集对象碰撞。但是，这不是你需要的效果。如果勾选 Is Trigger 属性，角色将穿过生命值可收集对象。物理系统会记录此碰撞，但由于还没有代码可处理碰撞，因此我们的游戏对碰撞没有反应。
4. 因此，我们还需要添加能接收碰撞效果的事件函数，我们可以创建一个新的组件用来检测我们的触发器是否正常碰撞。
   · 我们首先要在Assets/Scripts路径下创建一个名为 HealthCollectible 的C#脚本
   · 在 Hierarchy 中，选择 CollectibleHealth 游戏对象。将 HealthCollectible 脚本从 Project 窗口拖放到 Inspector，从而将这个脚本作为组件添加到游戏对象。
   · 双击脚本文件以便在脚本编辑器中打开此文件。我们要在新的脚本组件里面响应触发器碰撞效果，删除 Start 和 Update 函数，因为你不想在游戏开始时或在每一帧处理任何事务。你希望脚本检测 Ruby 与可收集的生命值游戏对象发生碰撞的情况，并向她提供一些生命值。为此，请使用以下特殊函数（事件函数）名称：OnTriggerEnter2D()
   · 提示：确保函数名称和参数类型的拼写正确，因为 Unity 在需要调用函数时会使用这些名称在脚本中“查找”函数。  
   与 Unity 每帧调用 Update 函数的方式相同，当检测到新的刚体进入触发器时，Unity 将在第一帧调用此 OnTriggerEnter2D 函数。名为 other 的参数将包含刚进入触发器的碰撞体。
5. 向该函数添加一个简单的 Debug.Log 以检查是什么进入了触发器
   · 提示：$是C#一个占位符，是为了替代string.format()，这样就不需要+号连接变量与字符串常量了，花括号里面按照变量值输出，括号外按常量输出。
6. 注释掉之前调用ChangeHealth的方法，保存，返回到 Unity 编辑器并单击 Play。现在，当 Ruby 接触到可收集对象时，事件函数就会执行一次，控制台中会显示一条消息，告诉你 Ruby 已进入触发器。
7. 如果我们希望知道碰撞次数，可以在HealthCollectible脚本里定义一个int collideCount变量，不赋初始值默认为0，然后类里面写一个collideCount自增的方法，每执行一次方法collideCount都会加一，这里可以用 collideCount = collideCount + 1 也可以用collideCount++简写。
8. 保存，返回到 Unity 编辑器并单击 Play，运行，控制台不但会提示发生了碰撞的对象，还会输出第n次碰撞。
  
至此，我们就通过unity的Collider的触发器配合OnTriggerEnter2D() 实现了碰撞检测，并复习了前面关于运算符的内容。
  
### 【百日挑战62】unity教程之2D游戏开发初步（二十五）
  
前言：在上期教程中，我们通过官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，通过C#脚本和触发器继续完善可收集对象中的向 Ruby 添加生命值统计功能，复习了Mathf.Clamp 方法的调用和使用，学习了触发器的概念，与常规碰撞体的区别，启用方法并在脚本中通过 OnTriggerEnter2D() 事件函数实现碰撞检测，今天我们继续完善角色设计生命系统并使用触发器实现创建可收集的生命值游戏对象，实现可收集的生命值游戏对象与玩家交互。
  
本节课目标：Ruby吃草莓加血。
  
操作步骤：  

1. 首先定位到 HealthCollectible 脚本，之前我们已经写过一个更改生命的脚本了，我们需要在其中添加一个变量控制每次加血的数值，访问权限公开。
2. 然后我们就可以在ChangeHealth()方法里面传入参数更改生命值，即每次碰撞草莓就会触发Trigger，执行里面的方法，改变Ruby的生命值，这里我们要获取Ruby游戏对象的脚本组件对象，我们需要先创建类的对象，用泛型方法方法 GetComponent<> 获取游戏对象的组件，即取指定类型的组件，根据尖括号里面的类型找到组件。如果只声明对象而不用 GetComponent 实例化会提示 NullReferenceException 错误。
3. 拿到游戏组件之后，我们就可以调用 RubyHealthSystem 组件内的方法实现更改生命值，但是我们关于加生命的类是写在 RubyHealthSystem 内的，而 ChangeHealth 方法又是属于 RubyHealthSystem 对象的，且不是静态类，我们无法直接调用，回顾之前跨类调用方法的知识，我们需要通过对象来调用，不过我们之前已经声明变量（局部变量）healthSystem了，然后直接把草莓加的血量值（amount）传递过来赋值到 healthSystem 内。
4. 如果无法访问到 RubyHealthSystem 组件内的 ChangeHealth() 方法，请检查 RubyHealthSystem 组件内 ChangeHealth() 方法的访问修饰符是否被设置为 Public，函数返回值类型前如果没有加访问修饰符，c#默认视为private（私有的），只有在自己的类体中可以访问，我们需要改为 Public 才能在外部被访问到。
5. 角色回完血之后，我们希望这个草莓消失，这里需要使用Destroy()方法，它也是继承自 MonoBehaviour 的方法，用于销毁游戏对象，DestroyObject(gameObject)可以自动获取当前组件所在的游戏对象，最后将 HealthCollectible 组件在预制件编辑模式下挂载到草莓 CollectibleHealth 对象，然后将 RubyMoveController 组件的 healthSystem 和 绑定到玩家Ruby对象即可。
   注：Destroy 是 Unity 的一个内置函数，可销毁你作为参数传递给这个函数的任何对象；在此示例中为 gameObject。这是将脚本附加到的游戏对象（可收集的生命值包）。
6. 为了测试草莓对象可以改变Ruby的生命值，我们先在inspector更改 HealthCollectible 组件的 amount 为 -1，然后保存并点击Play运行游戏。
  
让 Ruby 走到可收集的生命值包并收集这个包！当 Ruby 拾取生命值包时可以看到，当Ruby与草莓发生接触的时候，控制台会输出此时我们的生命值由之前设定的最大生命值5变成了4，且草莓消失，说明调用了 ChangeHealth() 方法的功能，且Destroy()方法被执行，对象正常销毁。
  
### 【百日挑战63】unity教程之2D游戏开发初步（二十六）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，通过C#脚本和触发器实现了可收集对象中的向 Ruby 添加生命值统计功能，通过调用 RubyHealthSystem 组件内的 ChangeHealth 方法实现更改生命值，实现了实现可收集的生命值游戏对象与玩家交互——Ruby吃草莓加血的目标，最后使用 Destroy 方法销毁游戏对象让草莓消失，学习了今天我们先复习下前面关于unity物理系统的各种概念.
  
### 1.1 刚体组件工作原理

发生碰撞时， 2D 刚体组件可以将碰撞将要导致的效果（如位移、旋转等），传达回 Transform 组件，Transform 组件就按照接收到的这些信息进行位移和旋转，表现出应用的碰撞效果

碰撞过程：

- collider 碰撞体 ---- 负责监测是否能够发生碰撞
- rigidbody 刚体 ---- 根据物理引擎设计的规则，产生碰撞后的效果数据
- Transform 变换 ---- 接收刚体传递过来的效果数据，将这些数据对应的效果表现出来，根据数据移动位置，发生旋转

> 注意:  
> 连接到同一 2D 刚体的多个 2D 碰撞体不会相互碰撞。这意味着可以创建一组碰撞体来有效充当单一复合碰撞体，使所有碰撞体都与 2D 刚体同步移动和旋转。

### 1.2 组件属性

![](../imgs/unity_Rigid2D.png)  
Rigidbody 2D组件属性

· 关于 Simulated

使用 Simulated 属性可停止（取消选中）和启动（检查）2D 刚体以及任何附加的 2D 碰撞体和 2D 关节与 2D 物理模拟系统之间的交互。与启用或禁用单个 2D 碰撞体和 2D 关节组件相比，对此属性进行更改将在内存和处理器方面具有更高的效率。

· 关于 Use Full Kinematic Contacts

如果希望 Kinematic 2D 刚体与所有 2D 刚体类型碰撞，请启用此设置（选中复选框）。这种情况下类似于 Dynamic 2D 刚体，不同之处在于 Kinematic 2D 刚体在接触另一 2D 刚体时不会被物理引擎移动，而会充当一个具有无限质量的不可移动对象。

### 1.3 Body Type 属性

Body Type 有三个选项；每个选项定义一种常见和固定的行为。附加到 2D 刚体的 2D 碰撞体将继承 2D 刚体的 Body Type。这三个选项是：

- Dynamic
- Kinematic
- Static

所选的选项将定义：

- 移动（位置和旋转）行为
- 碰撞体相互作用

Body Type 发生变化时，各种与质量相关的内部属性都将立即重新计算，并且在游戏对象的下一个 FixedUpdate 期间需要重新估算连接到 2D 刚体的 2D 碰撞体的所有现有触点。根据触点数量以及连接到刚体的 2D 碰撞体数量，更改 Body Type 可能会导致性能变化。

#### 1.3.1 Body Type：Dynamic 动态

![](../imgs/Rigidbody2DBodyType.png)
  
关于 Rigidbody2DBodyType：  
Dynamic 类型的 2D 刚体设计为在模拟条件下移动。这种刚体类型具有可用的全套属性（例如有限质量和阻力），并受重力和作用力的影响。Dynamic 刚体类型将与每个其他刚体类型碰撞，是最具互动性的刚体类型。这是需要移动的对象的最常见刚体类型，因此是 2D 刚体的默认刚体类型。此外，由于具有动态性并与周围所有对象互动，因此也是性能成本最高的刚体类型。选择此刚体类型时，所有 2D 刚体属性均可用。

> 注意：  
> 请勿使用变换组件来设置 Dynamic 类型的 2D 刚体的位置或旋转(不要直接通过编码来进行位置更改/移动)。模拟系统会根据 Dynamic 2D 刚体的速度对该刚体重新定位；可以通过脚本施加于刚体的力来直接更改此值，也可以通过碰撞和重力来间接更改此值。  
> 说白了，就是控制 Dynamic 类型的 2D 刚体移动或旋转时，不要直接更改值（会跟物理系统相互影响，导致移动效果很诡异），而要通过力来间接更改，才能保证较为拟真的效果

#### 1.3.2 Body Type：Kinematic 力学、运动学

![](../imgs/Rigidbody2D_Kinematic.png)  

关于Rigidbody2D_Kinematic：  
Kinematic 类型的 2D 刚体设计为在模拟条件下移动，但是仅在非常明确的用户控制下进行。虽然 Dynamic 2D 刚体受重力和作用力的影响，但 Kinematic 2D 刚体并不会受此影响。因此，Kinematic 2D 刚体的速度很快，与 Dynamic 2D 刚体相比，对系统资源的需求更低。Kinematic 2D 刚体按设计应通过 Rigidbody2D.MovePosition 或 Rigidbody2D.MoveRotation 进行显式重定位。应使用物理查询来检测碰撞，并通过脚本确定 2D 刚体应该移动的位置和方式。
  
Kinematic 2D 刚体仍然通过速度移动，但是此速度不受作用力和重力的影响。Kinematic 2D 刚体不会与其他 Kinematic 2D 刚体和 Static 2D 刚体碰撞，只会与 Dynamic 2D 刚体碰撞。与 Static 2D 刚体（见下文）相似，**Kinematic** 2D 刚体在碰撞期间的行为类似于不可移动的对象（就像具有无限质量）。选择此刚体类型时，与质量相关的属性将不可用。

#### 1.3.3 Body Type：Static 静态

![](../imgs/Rigidbody2D_Static.png)

Static 2D 刚体设计为在模拟条件下完全不动；如果任何对象与 Static 2D 刚体碰撞，此类型刚体的行为类似于不可移动的对象（就像具有无限质量）。此刚体类型也是使用资源最少的刚体类型。Static 刚体只能与 Dynamic 2D 刚体碰撞。不支持两个 Static 2D 刚体进行碰撞，因为这种刚体不是为了移动而设计的。

适合加到不会移动的固定物体上，比如 墙、树 等

可通过两种方法将 2D 刚体标记为 **Static**：

1.对于具有 2D 碰撞体组件的游戏对象，不附加任何 2D 刚体组件。所有此类 2D 碰撞体在内部均视为已附加到单个隐藏的 Static 2D 刚体组件。

2.对于需要附加 2D 刚体的游戏对象，将此 2D 刚体设置为 Static。

方法 1 是创建 Static 2D 碰撞体的快速方法。创建大量 Static 2D 碰撞体时，不为具有 2D 碰撞体的每个游戏对象添加 2D 刚体是比较容易实现的。

方法 2 用于提高性能。如果需要在运行时移动或重新配置 Static 2D 碰撞体，该碰撞体具有自己的 2D 刚体时完成这些操作会更快。如果需要在运行时移动或重新配置一组 2D 碰撞体，则将这些碰撞体全部设为一个标记为 Static 的父 2D 刚体的子代会比单独移动每个游戏对象更快。

注意：如上所述，**Static** 2D 刚体设计为不移动，因此不会考虑相交的两个 Static 2D 刚体对象之间的碰撞。然而，如果 Static 2D 刚体和 Kinematic 2D 刚体的其中一个 2D 碰撞体设置为触发器，两者就会交互作用。此外，还有一个功能可改变 Kinematic 刚体的交互对象（请参阅下文的 Use Full Kinematic Contacts）。

## 2. 2D 碰撞体

**2D 碰撞体**组件可定义用于物理碰撞的 2D 游戏对象的形状。碰撞体是不可见的，其形状不需要与游戏对象的网格完全相同；事实上，粗略近似方法通常更有效，在游戏运行过程中难以察觉。

可用于 2D 刚体的 2D 碰撞体类型为：

- 用于圆形碰撞区域的 2D 圆形碰撞体。
- 用于正方形和矩形碰撞区域的 2D 盒型碰撞体。
- 用于自由形状碰撞区域的 2D 多边形碰撞体。
- 用于自由形状碰撞区域和非全封闭区域（例如圆凸角）的 2D 边界碰撞体。
- 用于圆形或菱形碰撞区域的 2D 胶囊碰撞体。
- 用于合并 2D 盒型碰撞体与 2D 多边形碰撞体的 2D 复合碰撞体。

通用属性：

![](../imgs/unity_collider2d.png)

> 注意：  
> 2D 游戏对象的所有碰撞体的名称都以“2D”结尾。名称中没有“2D”的碰撞体将用于 3D 游戏对象。请注意，不能混用 3D 游戏对象和 2D 碰撞体，也不能混用 2D 游戏对象和 3D 碰撞体。

### 2.1 CompositeCollider2D 复合碰撞体

作用：可合并其他碰撞体的碰撞体。

与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。

2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。

![](../imgs/class-CompositeCollider2D.png)

当其他碰撞体的 Collider2D.usedByComposite 设置为 true 时，CompositeCollider2D 将其合并。

当复合碰撞体使用碰撞体时，Editor 将忽略并且不显示 Collider2D.sharedMaterial、Collider2D.isTrigger 和 Collider2D.usedByComposite 属性。而是使用 CompositeCollider2D 上的相同属性。应将复合碰撞体的这些属性设置为将所有碰撞体均合并到复合碰撞体中。

复合碰撞体只能合并 BoxCollider2D 和 PolygonCollider2D。

### 2.2 触发器

触发器（触发碰撞器）是一种特殊类型的碰撞体。触发器不会阻止移动，但是物理系统仍会检查角色是否会与触发器碰撞。它只检查碰撞，不负责其他物理效果，所以一般不会和刚体一起使用，当你的角色进入触发器时，你将收到一条消息，以便你可以处理该事件。

一句话总结：触发器碰撞体只监测碰撞，不阻止移动；碰撞时，可接收到消息，根据需求添加相关处理代码

使用步骤：

1. 为碰撞体组件选中 “Is Trigger” 复选框，再测试游戏，会发现碰撞体不再阻止移动了；但实际上，Unity 还是会通过碰撞体记录碰撞；

   ![](../imgs/unity_isTrigger.png)

2. 在使用触发器的游戏对象上添加脚本组件，在其中添加事件  
   void OnTriggerEnter2D(Collider2D other)  //OnTriggerEnter2D()用于响应触发器碰撞事件的一个事件方法  
   此事件会在每次被碰撞时执行，将你需要的逻辑代码（触发碰撞后需要执行的功能）写入事件方法中即可。

## 3. Collision2D 2D 碰撞细节类

[Collision2D API 文档](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Collision2D.html)

该类对象是回调函数返回的碰撞细节。用来描述碰撞过程本身

碰撞细节由 MonoBehaviour.OnCollisionEnter2D、MonoBehaviour.OnCollisionStay2D 和 MonoBehaviour.OnCollisionExit2D 回调返回。它详细说明了碰撞中涉及哪些 Collider2D 和 Rigidbody2D 对象，以及 Collider2D 相遇的接触点。

可以通过碰撞细节事件函数（回调函数）来编写两个刚体碰撞后的游戏逻辑

## 4. 2D 物理材质

2D 物理材质 (Physics Material 2D) 用于调整 2D 物理对象碰撞时这些对象之间的摩擦和弹性。可通过 Assets 菜单 (Assets > Create > Physics Material 2D) 创建 2D 物理材质。

![](../imgs/PhysicsMaterial2DInspector.png)

![](../imgs/Unity_2d_PhysicsMaterial.png)

使用方式：

要使用 2D 物理材质，只需将其拖动到已附加 2D 碰撞体的对象上，或将其拖动到 Inspector 中的碰撞体组件。

> 注意：  
> 在 3D 物理中，等效资源称为 Physic Material（物理材质）_（即 physic_ 末尾没有 S）。在脚本中不要混淆这两种拼写，这很重要。
  
### 【百日挑战64】unity教程之2D游戏开发初步（二十七）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，我们先复习下前面关于unity物理系统的各种概念，巩固了刚体组件工作原理、刚体组件属性、2D 碰撞体、2D 复合碰撞体、触发器、触发器模块的内容，今天我们继续完善通过C#脚本和触发器实现可收集对象中的向 Ruby 添加生命值统计功能，丰富和优化代码逻辑部分，添加重要的规则，并在其中学习C#基本概念——面向对象的封装。
  
1. 异常捕获：回到之前写的 HealthCollectible 组件，我们在其中调用了 healthSystem 对象，但在实际的项目中，为了避免使用游戏对象之前获取不到组件导致空引用异常，影响后面调用方法或值，所以在调用其他游戏对象的方法之前我们需要先判断是否为空，如果不为空则执行代码，空则不执行括号内的操作，而是抛出异常方便调试人员知晓问题，这样的操作也可以用try...catch...结构书写，即使出现异常也不会卡住整个程序。
2. 检查 Ruby 是否需要生命值：现在，如果你在 Ruby 的生命值满血时拾取一个生命值可收集对象，脚本仍将销毁该可收集对象。这是因为根据你的设置，当角色进入触发器时，无论如何都要删除可收集对象。我们希望当角色生命值满了之后就无法拾取草莓，这里同样可以用if语句来判断。
为了避免这种情况，你可以添加一项检查——在拾取草莓之前先判断当前的生命值是否大于等于生命上限，反之拾取并增加生命值，以便在销毁生命值可收集对象之前先查看 Ruby 是否需要生命值：
  
  我们很轻松就写完了判定的条件，这个脚本中添加了另一项测试以查看 Ruby 的生命值是否小于最大生命值。如果相等，该测试的结果将为 false，并且脚本将跳过 if 语句（因为无需更改生命值或销毁可收集对象）。
但在切换回 Unity 之前请先等等！你可能已经猜到在控制台中会有一个错误，这是正常的；currentHealth 是私有变量，因此你无法从外部访问这个变量。
  
  你可以像以前一样将这个变量设置为公共 (public) 变量。尽管代码是可以运行的，但是这会留下巨大隐患，玩家当前生命值是一个很重要的变量，我们直接暴露所有权限，让变量可在任意的类读写是不安全的，有时候将所有内容都公开会导致错误，尤其是对于某些内容，你可能并不希望从任何位置都可以访问和更改它们，显然这也违反了封装性原则，我们要求只有游戏内的特定逻辑或当前的类才能更改
  
  例如，如果将 currentHealth 设置为 public，则可以在另一个脚本中将这个变量更改为 10，即使 maxHealth 仅为 5 的情况下也可以这样修改。为避免这种情况，最好只允许通过函数进行更改。这样做便于执行检查，就像 ChangeHealth 函数一样，可以使用钳制功能确保生命值绝不会小于 0，也不会大于 maxHealth。
  
  这里会出现一个问题，healthSystem.currentHealth变量在另外一个类中，而 currentHealth 的访问权限被设置为Private，默认情况下我们是不可以直接在外部类访问的，那你不又想将这个变量公开（以防止其他脚本进行更改），但是仍然希望允许其他脚本读取 currentHealth 的值（但这些脚本无法写入值）。要怎么做呢？如果把角色当前生命设置成可访问但只读的是不是比较安全呢？为此，你可以使用属性。
3. 回到 RubyHealthSystem 组件，我们为 currentHealth 变量设置属性。然后将原先脚本里的 currentHealth 字段全部替换成 _currentHealth 加以区分，说白了，属性就是字段的取值器（赋值器），属性是一种特殊的函数结构。重点阅读注释！
4. 如果我们要设置 set 赋值器，为赋值设置属性，则可以按照下面的写法，这样写法的权限等同于 Public。
5. 我们希望字段只能在当前内赋值，就使用 public int _currentHealth { get { return currentHealth; }} 属性
  
注意：如果把字段（变量值）属性比作一个小盒子，那属性相当于装这个小盒子的大箱子，属性可以限制字段，属性是对字段的封装，我们可以通过属性，使得字段不可随意被外部访问，你可以在其中设定各种访问规则，例如 get set、get private set、get protected set 等等仅读仅写或读写时候满足某种需求才能操作..这样的规则，相当于就是把字段封装起来，我们要访问这些字段是依靠属性的，这就是所谓的封装。至此，这样的封装我们就能很方便的控制数据的可访问性，起到保护数据的目的，而封装这些私有字段的东西，就叫属性，这就是C#里面非常重要的概念——封装。
  
6. 最后回到 HealthCollectible 组件，在if语句里面调用对象 healthSystem 对象的 currentHealth 属性就大功告成了。
7. 为了测试草莓对象可以改变Ruby的生命值，我们先在 RubyHealthSystem 组件更改 _currentHealth 的值为4，最后保存点击Play，运行我们的游戏，让我们的Ruby靠近草莓，观察草莓状态以及控制台打印的信息。
8. 可以看到我们的草莓消失，并在控制台输出玩家当前的生命值增加了1，由4变成了5。
9. 如果让玩家一开始就处于满血状态，则控制台只会打印关于碰撞的信息，if语句内的代码则不会执行。即不会增加玩家生命值，也不会销毁游戏对象。
  
我们再来review下我们的代码：
  
1. If 语句检查测试对象是否为空：

然后，你引入了一个新脚本概念，即 if 语句。if 语句在你的代码中引入决策功能。该语句将条件添加在两个括号之间；如果该条件成立，Unity 将执行随后的两个花括号之间的代码。

否则会跳过这些代码行，然后在右花括号后继续执行（在此示例中不执行任何其他操作，因为该函数在这个位置结束）。
  
你在此处使用的条件是：controller != null
  
!= 表示“不等于”（与表示“等于”的 == 相反）。因此，我们在这个条件中测试存储在控制器中的值是否不等于 null。null 是一个特殊值，表示“无/空”。
  
那么，为什么要测试控制器变量是否为空？如果你添加另一个移动的游戏对象（例如敌人），则进入触发器便会调用该函数。但是，随后 GetComponent 在该游戏对象上找不到 RubyController（因为该游戏对象是敌人，而不是玩家角色）。
  
由于 GetComponent 无法为你提供 RubyController，因此该函数将返回 null，并且你无法在空变量上调用该函数。进行此测试可确保你仅向 Ruby 提供生命值，而不会产生错误（尝试对其他对象执行此操作）。

2. 定义属性：
   public int health { get { return currentHealth; }}
   int currentHealth;
  
你通过以下要素开始了像变量一样的属性定义：
  · 访问级别 (public)
  · 类型 (int)
  · 名称 (health)

但是，此处添加了两个 { } 代码块，而未使用 ; 来结束代码行。
  
在第一个代码块中，你使用了 get 关键字来获取第二个代码块中的任何内容。
  
第二个代码块就像普通函数一样，因此只需返回 currentHealth 值。
  
编译器完全像函数一样处理此代码行，因此你可以在 get 代码块内的函数中编写所需的任何内容（例如声明变量、执行计算和调用其他函数）。
  
至此，我们就设计完了可收集对象中的向 Ruby 添加生命值统计功能，通过触发器碰撞方法实现玩家与游戏对象之间的交互，碰撞时候就执行一次，满血的时候无法拾取草莓，残血的时候可以拾取并消失，且当前生命值不能超过生命上限。我们在这期间通过只读属性对 _currentHealth 进行封装，学习了C#面向对象最重要的特性之一——封装。
  
### 【百日挑战65】unity教程之2D游戏开发初步（二十八）
  
前言：在上期教程中，我们在官方一个新的2D的RPG游戏教程系列《RubyAdventure2DRpg》，我们设计完了可收集对象中的向 Ruby 添加生命值统计功能，通过触发器碰撞方法实现玩家与游戏对象之间的交互，碰撞时候就执行一次，满血的时候无法拾取草莓，残血的时候可以拾取并消失，且当前生命值不能超过生命上限。我们在这期间还掌握了在调用其他对象方法前判断为空提高严谨性，通过只读属性对 _currentHealth 进行封装，学习了C#面向对象最重要的特性之一——封装，今天我们继续学习世界交互中的设置伤害区域和敌人。
  
目标：你将使用触发器检测角色处于特定区域时对角色造成伤害。并设置伤害规则，我们还需要设置一个敌人——一个在区域中来回移动的机器人，如果玩家被这只机器人捉住则会受到生命值减少的惩罚。
  
步骤：
  
1. 放置素材：先前的教程中已介绍添加伤害区域所需的所有知识，因此请先自己尝试这个操作！你将在 Assets > Art > Sprites > Environment 中为区域找到一个名为 Damageable 的精灵。
2. 从 Damageable 精灵创建一个新的游戏对象。你可以从以下方法中选择：
  · 将精灵拖放到 Hierarchy 窗口中。
  · 新建一个游戏对象，然后添加 Sprite Renderer 组件并分配该精灵。

  放置完了游戏对象之后，调整它的位置和缩放，然后将该游戏对象从 Hierarchy 拖入 Project 窗口中的 Prefab 文件夹，生成预制件，双击打开这个进入预制件编辑模式。
3. 添加触发器：将 Box Collider 2D 组件添加到 Damageable 游戏对象，然后调整盒子的大小以适应精灵，并在 Inspector 中启用 Is Trigger 复选框。使得玩家可以走上去而不是挡住玩家。
4. 添加碰撞事件：创建一个名为 DamageZone 的新脚本。在 Project 窗口中，找到 Assets > Scripts 文件夹。右键单击，然后选择 Create > C# Script。
5. 添加触发器事件：在 Project 窗口中双击该脚本以在代码编辑器中打开脚本，删除Start和Update方法然后将以下代码复制到新脚本中以替换其中已有的类。DamageZone 脚本与上一教程的 Collectable 脚本完全一样，只是这里的生命值变化为 -1，而且删除了对 Destroy 的调用：
   稍微完善下我们的 DamageZone 组件，我们先声明一个公有的整型变量 damageNum，便于我们在 inspector 中调整减血量。然后赋初始值 -1.再将之前的 healthSystem.ChangeHealth(-1); 改为 healthSystem.ChangeHealth(damageNum);
6. 在 RubyMoveController 组件中将 rigidbody2d.position = position 改成 rigidbody2d.MovePosition(position); 这样做可以才能应用到刚体的休眠模式属性。
7. 然后将该脚本添加到 Damageable 游戏对象。按 Play 并让 Ruby 围绕此区域走动。查看控制台，其中会打印 Ruby 的新生命值！可以看到我们Ruby的生命值减少了。
8. 再次运行游戏，这很好，但只有在角色进入区域时才会伤害角色。如果角色停留在区域内，则不会再伤害角色。可以通过将函数名称从 OnTriggerEnter2D 更改为 OnTriggerStay2D 来解决此问题。刚体在触发器内的每一帧都会调用此函数，而不是在刚体刚进入时仅调用一次。
9.  现在，Ruby 会一直受到伤害，并且受到的伤害可能有点过多了！Ruby 在不到一秒的时间内生命值就变成了 0（帧数恰好等于她的生命值）。而且你可能还注意到，当你停止移动 Ruby 时，你在控制台上不会收到任何消息，因此 Ruby 站着不动时不会受到伤害。我们希望Ruby处于 Damageable 区域不断减血。且频率慢点
10. 要解决最后这个问题，你需要打开角色预制件，然后在 Rigidbody 组件中将 Sleeping Mode 设置为 Never Sleep：
11. 为了优化资源，物理系统在刚体停止移动时会停止计算刚体的碰撞；此时刚体进入“睡眠状态”。但在你这个情况中，你希望始终进行计算，因为即使在 Ruby 停止移动时也需要检测她是否受到伤害，因此你要指示刚体永远不要进入睡眠状态。
  
注意01：  
· Collider2D.OnTriggerEnter2D(Collider2D)：当另一个对象进入附加到该对象的触发碰撞器时发送（仅限 2D 物理）。
· Collider2D.OnTriggerExit2D(Collider2D)：当另一个对象离开附加到该对象的触发碰撞器时发送（仅限 2D 物理）。
· Collider2D.OnTriggerStay2D(Collider2D)：当另一个对象位于附加到该对象的触发碰撞器内时发送每个帧（仅限 2D 物理）。
  
注意02：关于 Sleeping Mode（休眠模式）  
作用：定义游戏对象在静止时如何“睡眠”以节省处理器时间。
  
· Never Sleep：禁用睡眠（应尽可能避免此设置，否则会影响系统资源）。
· Start Awake：游戏对象最初处于唤醒状态。（一段时间内保持清醒，若对象不活动则休眠）
· Start Asleep：游戏对象最初处于睡眠状态，但可以被碰撞唤醒。
  
这节课我们还是留下了个问题：当Ruby进入减血区域之后掉血太快，不符合正常的游戏玩法，下期我们将继续完善 DamageZone 组件的代码。延长检测间隔。
  

  
<br>

<hr>
<br>

配套视频教程：
[https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912](https://space.bilibili.com/43644141/channel/seriesdetail?sid=299912)

文章也同时同步微信公众号，喜欢使用手机观看文章的可以关注

![](../imgs/微信公众号二维码.jpg)
